import { s as safeAsync, e as validateOwnership, v as validateRequired, g as getDefaultSM2Params, d as validateDocument, V as ValidationError, c as createDatabaseOperations, D as DatabaseError, N as NotFoundError, f as validateQuality, S as SM2Error, h as calculateNextReviewDate, a as sanitizeInput, b as DuplicateError } from './validation_DQbs7Sb1.mjs';

const FlashcardSchema = {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: [
        "cardId",
        "userId",
        "front",
        "back",
        "category",
        "sm2",
        "createdAt",
        "updatedAt"
      ],
      properties: {
        cardId: {
          bsonType: "string",
          description: "Unique card identifier"
        },
        userId: {
          bsonType: "string",
          description: "Owner user ID"
        },
        front: {
          bsonType: "string",
          maxLength: 1e3,
          description: "Card front content"
        },
        back: {
          bsonType: "string",
          maxLength: 1e3,
          description: "Card back content"
        },
        exampleFront: {
          bsonType: ["string", "null"],
          maxLength: 1e3,
          description: "Example sentence in front language"
        },
        exampleBack: {
          bsonType: ["string", "null"],
          maxLength: 1e3,
          description: "Example sentence in back language"
        },
        audioUrl: {
          bsonType: ["string", "null"],
          description: "Pronunciation audio URL",
          pattern: "^https?://.+"
        },
        imageUrl: {
          bsonType: ["string", "null"],
          description: "Illustrative image URL",
          pattern: "^https?://.+"
        },
        tags: {
          bsonType: "array",
          items: {
            bsonType: "string",
            maxLength: 50
          },
          description: "Card tags for organization"
        },
        category: {
          bsonType: "string",
          maxLength: 100,
          description: "Card category"
        },
        difficulty: {
          enum: ["easy", "medium", "hard"],
          description: "Perceived difficulty level"
        },
        metadata: {
          bsonType: "object",
          properties: {
            source: {
              bsonType: "string",
              maxLength: 200,
              description: "Content source"
            },
            createdByAI: {
              bsonType: "bool",
              description: "Generated by AI"
            },
            aiModel: {
              bsonType: "string",
              maxLength: 100,
              description: "AI model used for generation"
            },
            confidence: {
              bsonType: "double",
              minimum: 0,
              maximum: 1,
              description: "AI confidence score"
            }
          }
        },
        sm2: {
          bsonType: "object",
          required: ["easeFactor", "interval", "repetitions", "nextReviewDate"],
          properties: {
            easeFactor: {
              bsonType: "double",
              minimum: 1.3,
              maximum: 2.5,
              description: "SM-2 ease factor"
            },
            interval: {
              bsonType: "int",
              minimum: 1,
              description: "Current interval in days"
            },
            repetitions: {
              bsonType: "int",
              minimum: 0,
              description: "Successful recalls in a row"
            },
            nextReviewDate: {
              bsonType: "date",
              description: "Next review due date"
            },
            lastReviewed: {
              bsonType: ["date", "null"],
              description: "Last review timestamp"
            },
            qualityResponses: {
              bsonType: "array",
              items: {
                bsonType: "int",
                minimum: 0,
                maximum: 5
              },
              description: "Historical quality responses"
            },
            totalReviews: {
              bsonType: "int",
              minimum: 0,
              description: "Total review attempts"
            },
            correctStreak: {
              bsonType: "int",
              minimum: 0,
              description: "Current correct answers streak"
            },
            incorrectStreak: {
              bsonType: "int",
              minimum: 0,
              description: "Current incorrect answers streak"
            },
            isSuspended: {
              bsonType: "bool",
              description: "Card temporarily suspended"
            },
            suspensionReason: {
              bsonType: "string",
              maxLength: 200,
              description: "Reason for suspension"
            }
          }
        },
        statistics: {
          bsonType: "object",
          properties: {
            timesCorrect: {
              bsonType: "int",
              minimum: 0,
              description: "Total correct responses"
            },
            timesIncorrect: {
              bsonType: "int",
              minimum: 0,
              description: "Total incorrect responses"
            },
            averageResponseTime: {
              bsonType: "double",
              minimum: 0,
              description: "Average response time in seconds"
            },
            lastDifficulty: {
              enum: ["easy", "medium", "hard"],
              description: "Last reported difficulty"
            }
          }
        },
        createdAt: {
          bsonType: "date",
          description: "Card creation timestamp"
        },
        updatedAt: {
          bsonType: "date",
          description: "Card last update timestamp"
        },
        version: {
          bsonType: "int",
          minimum: 1,
          description: "Schema version"
        }
      }
    }
  }
};

const COLLECTION_NAME = "flashcards";
const dbOps = createDatabaseOperations(COLLECTION_NAME);
class FlashcardsService {
  /**
   * Create a new flashcard
   */
  async createFlashcard(cardData, userId) {
    return safeAsync(
      async () => {
        validateOwnership(cardData.userId, userId, COLLECTION_NAME);
        validateRequired(
          cardData,
          ["cardId", "userId", "front", "back", "category"],
          COLLECTION_NAME
        );
        const sanitizedData = this.sanitizeCardData(cardData);
        const sm2Params = getDefaultSM2Params();
        const statistics = {
          timesCorrect: 0,
          timesIncorrect: 0,
          averageResponseTime: 0,
          lastDifficulty: "medium"
        };
        const completeCardData = {
          ...sanitizedData,
          sm2: sm2Params,
          statistics
        };
        const validation = validateDocument(completeCardData, FlashcardSchema);
        if (!validation.isValid) {
          throw new ValidationError(
            `Flashcard validation failed: ${validation.errors.join(", ")}`,
            "create_flashcard",
            COLLECTION_NAME
          );
        }
        await this.checkForDuplicateCard(
          sanitizedData.userId,
          sanitizedData.cardId
        );
        const result = await dbOps.create(
          completeCardData
        );
        if (!result.success) {
          throw new DatabaseError(
            result.error || "Failed to create flashcard",
            "CREATE_FLASHCARD_FAILED",
            "create_flashcard",
            COLLECTION_NAME
          );
        }
        return result;
      },
      { operation: "create_flashcard", collection: COLLECTION_NAME, userId }
    );
  }
  /**
   * Get flashcard by ID
   */
  async getFlashcardById(cardId, userId) {
    return safeAsync(
      async () => {
        const result = await dbOps.findOne({
          cardId,
          userId
        });
        if (!result.success) {
          throw new DatabaseError(
            result.error || "Failed to retrieve flashcard",
            "GET_FLASHCARD_FAILED",
            "get_flashcard_by_id",
            COLLECTION_NAME
          );
        }
        if (!result.data) {
          throw new NotFoundError(
            `Flashcard with ID ${cardId} not found`,
            "get_flashcard_by_id",
            COLLECTION_NAME,
            cardId
          );
        }
        return result;
      },
      { operation: "get_flashcard_by_id", collection: COLLECTION_NAME, userId }
    );
  }
  /**
   * Update flashcard content
   */
  async updateFlashcard(cardId, updates, userId) {
    return safeAsync(
      async () => {
        const currentCard = await this.getFlashcardById(cardId, userId);
        if (!currentCard.success || !currentCard.data) {
          throw new NotFoundError(
            `Flashcard with ID ${cardId} not found`,
            "update_flashcard",
            COLLECTION_NAME,
            cardId
          );
        }
        const sanitizedUpdates = this.sanitizeCardData(updates);
        const updatedData = { ...currentCard.data, ...sanitizedUpdates };
        const validation = validateDocument(updatedData, FlashcardSchema);
        if (!validation.isValid) {
          throw new ValidationError(
            `Flashcard validation failed: ${validation.errors.join(", ")}`,
            "update_flashcard",
            COLLECTION_NAME
          );
        }
        const result = await dbOps.updateOne(
          { cardId, userId },
          { $set: sanitizedUpdates }
        );
        if (!result.success) {
          throw new DatabaseError(
            result.error || "Failed to update flashcard",
            "UPDATE_FLASHCARD_FAILED",
            "update_flashcard",
            COLLECTION_NAME
          );
        }
        return this.getFlashcardById(cardId, userId);
      },
      { operation: "update_flashcard", collection: COLLECTION_NAME, userId }
    );
  }
  /**
   * Process SM-2 algorithm review response
   */
  async processReviewResponse(cardId, quality, responseTime, userId) {
    return safeAsync(
      async () => {
        validateQuality(quality);
        const currentCard = await this.getFlashcardById(cardId, userId);
        if (!currentCard.success || !currentCard.data) {
          throw new NotFoundError(
            `Flashcard with ID ${cardId} not found`,
            "process_review_response",
            COLLECTION_NAME,
            cardId
          );
        }
        const card = currentCard.data;
        const newSM2Params = this.calculateNewSM2Params(card.sm2, quality);
        const newStatistics = this.updateCardStatistics(
          card.statistics,
          quality,
          responseTime
        );
        const updates = {
          sm2: {
            ...newSM2Params,
            lastReviewed: /* @__PURE__ */ new Date(),
            qualityResponses: [...card.sm2.qualityResponses || [], quality],
            totalReviews: (card.sm2.totalReviews || 0) + 1
          },
          statistics: newStatistics
        };
        const result = await dbOps.updateOne(
          { cardId, userId },
          { $set: updates }
        );
        if (!result.success) {
          throw new SM2Error(
            result.error || "Failed to process review response",
            "process_review_response",
            COLLECTION_NAME,
            quality
          );
        }
        return this.getFlashcardById(cardId, userId);
      },
      {
        operation: "process_review_response",
        collection: COLLECTION_NAME,
        userId
      }
    );
  }
  /**
   * Get due flashcards for review
   */
  async getDueFlashcards(userId, options = {}) {
    return safeAsync(
      async () => {
        const now = /* @__PURE__ */ new Date();
        const baseQuery = { userId };
        if (options.category) {
          baseQuery.category = options.category;
        }
        if (options.difficulty) {
          baseQuery.difficulty = options.difficulty;
        }
        const fetchLimit = options.includeSuspended ? Math.max(options.limit || 50, 500) : options.limit || 50;
        const result = await dbOps.findMany(baseQuery, {
          limit: fetchLimit,
          sort: { createdAt: -1 }
        });
        if (!result.success) {
          throw new DatabaseError(
            result.error || "Failed to retrieve due flashcards",
            "GET_DUE_FLASHCARDS_FAILED",
            "get_due_flashcards",
            COLLECTION_NAME
          );
        }
        const cards = (result.data || []).filter(
          (card) => Boolean(card)
        );
        const filteredCards = cards.filter((card) => {
          const sm2 = card.sm2;
          if (!sm2 || !(sm2.nextReviewDate instanceof Date)) {
            return false;
          }
          if (sm2.isSuspended) {
            return options.includeSuspended;
          }
          return sm2.nextReviewDate.getTime() <= now.getTime();
        }).sort(
          (a, b) => a.sm2.nextReviewDate.getTime() - b.sm2.nextReviewDate.getTime()
        ).slice(0, options.limit || 50);
        return {
          success: true,
          data: filteredCards,
          operationTime: result.operationTime
        };
      },
      { operation: "get_due_flashcards", collection: COLLECTION_NAME, userId }
    );
  }
  /**
   * Get flashcards by category
   */
  async getFlashcardsByCategory(userId, category, options = {}) {
    return safeAsync(
      async () => {
        const result = await dbOps.findMany(
          { userId, category },
          {
            limit: options.limit || 50,
            skip: options.skip || 0,
            sort: { createdAt: -1 }
          }
        );
        if (!result.success) {
          throw new DatabaseError(
            result.error || "Failed to retrieve flashcards by category",
            "GET_FLASHCARDS_BY_CATEGORY_FAILED",
            "get_flashcards_by_category",
            COLLECTION_NAME
          );
        }
        return result;
      },
      {
        operation: "get_flashcards_by_category",
        collection: COLLECTION_NAME,
        userId
      }
    );
  }
  /**
   * Get all flashcards for a user
   */
  async getAllFlashcards(userId, options = {}) {
    return safeAsync(
      async () => {
        const result = await dbOps.findMany(
          { userId },
          {
            limit: options.limit || 1e3,
            skip: options.skip || 0,
            sort: { createdAt: -1 }
          }
        );
        if (!result.success) {
          throw new DatabaseError(
            result.error || "Failed to retrieve all flashcards",
            "GET_ALL_FLASHCARDS_FAILED",
            "get_all_flashcards",
            COLLECTION_NAME
          );
        }
        return result;
      },
      { operation: "get_all_flashcards", collection: COLLECTION_NAME, userId }
    );
  }
  /**
   * Search flashcards by content
   */
  async searchFlashcards(userId, searchTerm, options = {}) {
    return safeAsync(
      async () => {
        const query = {
          userId,
          $or: [
            { front: new RegExp(searchTerm, "i") },
            { back: new RegExp(searchTerm, "i") },
            { exampleFront: new RegExp(searchTerm, "i") },
            { exampleBack: new RegExp(searchTerm, "i") },
            { tags: { $in: [new RegExp(searchTerm, "i")] } }
          ]
        };
        if (options.category) {
          query.category = options.category;
        }
        const result = await dbOps.findMany(query, {
          limit: options.limit || 20,
          sort: { createdAt: -1 }
        });
        if (!result.success) {
          throw new DatabaseError(
            result.error || "Failed to search flashcards",
            "SEARCH_FLASHCARDS_FAILED",
            "search_flashcards",
            COLLECTION_NAME
          );
        }
        return result;
      },
      { operation: "search_flashcards", collection: COLLECTION_NAME, userId }
    );
  }
  /**
   * Suspend or unsuspend a flashcard
   */
  async suspendFlashcard(cardId, suspended, reason, userId) {
    return safeAsync(
      async () => {
        const updates = {
          "sm2.isSuspended": suspended,
          "sm2.suspensionReason": suspended ? reason : null
        };
        if (suspended) {
          updates["sm2.nextReviewDate"] = new Date(
            Date.now() + 365 * 24 * 60 * 60 * 1e3
          );
        } else {
          const currentCard = await this.getFlashcardById(cardId, userId);
          if (currentCard.success && currentCard.data) {
            updates["sm2.nextReviewDate"] = calculateNextReviewDate(
              currentCard.data.sm2.interval,
              currentCard.data.sm2.easeFactor,
              3
              // Assume good quality for resumption
            );
          }
        }
        const result = await dbOps.updateOne(
          { cardId, userId },
          { $set: updates }
        );
        if (!result.success) {
          throw new DatabaseError(
            result.error || `Failed to ${suspended ? "suspend" : "unsuspend"} flashcard`,
            "SUSPEND_FLASHCARD_FAILED",
            "suspend_flashcard",
            COLLECTION_NAME
          );
        }
        return this.getFlashcardById(cardId, userId);
      },
      { operation: "suspend_flashcard", collection: COLLECTION_NAME, userId }
    );
  }
  /**
   * Delete flashcard
   */
  async deleteFlashcard(cardId, userId) {
    return safeAsync(
      async () => {
        const result = await dbOps.deleteOne({ cardId, userId });
        if (!result.success) {
          throw new DatabaseError(
            result.error || "Failed to delete flashcard",
            "DELETE_FLASHCARD_FAILED",
            "delete_flashcard",
            COLLECTION_NAME
          );
        }
        return result;
      },
      { operation: "delete_flashcard", collection: COLLECTION_NAME, userId }
    );
  }
  /**
   * Get flashcard statistics
   */
  async getFlashcardStats(userId, cardId) {
    return safeAsync(
      async () => {
        const matchStage = { userId };
        if (cardId) {
          matchStage.cardId = cardId;
        }
        const flashcardsResult = await dbOps.findMany(
          matchStage
        );
        if (!flashcardsResult.success) {
          throw new DatabaseError(
            flashcardsResult.error || "Failed to get flashcard statistics",
            "GET_FLASHCARD_STATS_FAILED",
            "get_flashcard_stats",
            COLLECTION_NAME
          );
        }
        const cards = flashcardsResult.data || [];
        const totals = cards.reduce(
          (acc, card) => {
            acc.totalCards += 1;
            const repetitions = card.sm2?.repetitions ?? 0;
            if (repetitions === 0) {
              acc.newCards += 1;
            } else if (repetitions < 5) {
              acc.learningCards += 1;
            } else {
              acc.matureCards += 1;
            }
            if (card.sm2?.isSuspended) {
              acc.suspendedCards += 1;
            }
            if (typeof card.sm2?.easeFactor === "number") {
              acc.totalEaseFactor += card.sm2.easeFactor;
            }
            if (typeof card.sm2?.interval === "number") {
              acc.totalInterval += card.sm2.interval;
            }
            if (typeof card.sm2?.totalReviews === "number") {
              acc.totalReviews += card.sm2.totalReviews;
            }
            return acc;
          },
          {
            totalCards: 0,
            newCards: 0,
            learningCards: 0,
            matureCards: 0,
            suspendedCards: 0,
            totalEaseFactor: 0,
            totalInterval: 0,
            totalReviews: 0
          }
        );
        const averageEaseFactor = totals.totalCards > 0 ? totals.totalEaseFactor / totals.totalCards : 0;
        const averageInterval = totals.totalCards > 0 ? totals.totalInterval / totals.totalCards : 0;
        return {
          success: true,
          data: {
            totalCards: totals.totalCards,
            newCards: totals.newCards,
            learningCards: totals.learningCards,
            matureCards: totals.matureCards,
            suspendedCards: totals.suspendedCards,
            averageEaseFactor,
            averageInterval,
            totalReviews: totals.totalReviews
          },
          operationTime: flashcardsResult.operationTime
        };
      },
      { operation: "get_flashcard_stats", collection: COLLECTION_NAME, userId }
    );
  }
  // ============================================================================
  // PRIVATE HELPER METHODS
  // ============================================================================
  /**
   * Sanitize flashcard data
   */
  sanitizeCardData(cardData) {
    const sanitized = { ...cardData };
    if (sanitized.front)
      sanitized.front = sanitizeInput(String(sanitized.front));
    if (sanitized.back) sanitized.back = sanitizeInput(String(sanitized.back));
    if (sanitized.exampleFront)
      sanitized.exampleFront = sanitizeInput(String(sanitized.exampleFront));
    if (sanitized.exampleBack)
      sanitized.exampleBack = sanitizeInput(String(sanitized.exampleBack));
    if (sanitized.category)
      sanitized.category = sanitizeInput(String(sanitized.category));
    if (sanitized.tags && Array.isArray(sanitized.tags)) {
      sanitized.tags = sanitized.tags.map(
        (tag) => sanitizeInput(String(tag))
      );
    }
    return sanitized;
  }
  /**
   * Check for duplicate card ID for the same user
   */
  async checkForDuplicateCard(userId, cardId) {
    const existingCard = await dbOps.findOne({ userId, cardId });
    if (existingCard.success && existingCard.data) {
      throw new DuplicateError(
        `Flashcard with ID ${cardId} already exists for this user`,
        "create_flashcard",
        COLLECTION_NAME,
        "cardId",
        cardId
      );
    }
  }
  /**
   * Calculate new SM-2 parameters based on quality response
   */
  calculateNewSM2Params(currentSM2, quality) {
    const easeFactor = currentSM2.easeFactor;
    const repetitions = currentSM2.repetitions;
    const interval = currentSM2.interval;
    const updatedEaseFactor = Math.max(
      1.3,
      easeFactor + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02))
    );
    let updatedInterval = interval;
    let updatedRepetitions = repetitions;
    if (quality >= 3) {
      if (repetitions === 0) {
        updatedInterval = 1;
      } else if (repetitions === 1) {
        updatedInterval = 6;
      } else {
        updatedInterval = Math.round(interval * updatedEaseFactor);
      }
      updatedRepetitions = repetitions + 1;
    } else {
      updatedRepetitions = 0;
      updatedInterval = 1;
    }
    const nextReviewDate = calculateNextReviewDate(
      updatedInterval,
      updatedEaseFactor,
      quality
    );
    const correctStreak = quality >= 3 ? (currentSM2.correctStreak ?? 0) + 1 : 0;
    const incorrectStreak = quality >= 3 ? 0 : (currentSM2.incorrectStreak ?? 0) + 1;
    return {
      ...currentSM2,
      easeFactor: updatedEaseFactor,
      interval: updatedInterval,
      repetitions: updatedRepetitions,
      nextReviewDate,
      correctStreak,
      incorrectStreak
    };
  }
  /**
   * Update card statistics based on review response
   */
  updateCardStatistics(currentStats, quality, responseTime) {
    const timesCorrect = currentStats.timesCorrect;
    const timesIncorrect = currentStats.timesIncorrect;
    const averageResponseTime = currentStats.averageResponseTime;
    const updatedTimesCorrect = quality >= 3 ? timesCorrect + 1 : timesCorrect;
    const updatedTimesIncorrect = quality >= 3 ? timesIncorrect : timesIncorrect + 1;
    const totalResponses = updatedTimesCorrect + updatedTimesIncorrect;
    let updatedAverageResponseTime = averageResponseTime;
    if (totalResponses > 0) {
      const previousResponses = timesCorrect + timesIncorrect;
      const previousTotalTime = averageResponseTime * previousResponses;
      updatedAverageResponseTime = (previousTotalTime + responseTime) / totalResponses;
    }
    const correctRate = totalResponses > 0 ? updatedTimesCorrect / totalResponses : 0;
    let lastDifficulty = currentStats.lastDifficulty;
    if (correctRate >= 0.8) {
      lastDifficulty = "easy";
    } else if (correctRate >= 0.6) {
      lastDifficulty = "medium";
    } else {
      lastDifficulty = "hard";
    }
    return {
      timesCorrect: updatedTimesCorrect,
      timesIncorrect: updatedTimesIncorrect,
      averageResponseTime: updatedAverageResponseTime,
      lastDifficulty
    };
  }
}
const flashcardsService = new FlashcardsService();

export { FlashcardSchema as F, flashcardsService as f };
