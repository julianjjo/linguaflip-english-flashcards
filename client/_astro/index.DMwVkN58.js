import{d as D}from"./utils.C1pdIpZs.js";import{m as ae}from"./vendor.QRJdyujs.js";import"./Header.astro_astro_type_script_index_0_lang.D70yTJYG.js";import"./react-vendor.DGywmNEQ.js";import"./state-vendor.AbkSLUgN.js";import"./hooks.Bgys84ol.js";import"./flashcard-components.Dmu1f7E8.js";ae.config({path:".env.local"});const re=[`CREATE TABLE IF NOT EXISTS users (
    id TEXT PRIMARY KEY,
    userId TEXT NOT NULL UNIQUE,
    email TEXT UNIQUE,
    username TEXT,
    createdAt TEXT NOT NULL,
    updatedAt TEXT NOT NULL,
    document TEXT NOT NULL
  )`,"CREATE UNIQUE INDEX IF NOT EXISTS idx_users_email ON users(email)",`CREATE TABLE IF NOT EXISTS flashcards (
    id TEXT PRIMARY KEY,
    userId TEXT NOT NULL,
    cardId TEXT NOT NULL,
    category TEXT,
    difficulty TEXT,
    createdAt TEXT NOT NULL,
    updatedAt TEXT NOT NULL,
    document TEXT NOT NULL,
    UNIQUE(userId, cardId)
  )`,"CREATE INDEX IF NOT EXISTS idx_flashcards_user ON flashcards(userId)","CREATE INDEX IF NOT EXISTS idx_flashcards_category ON flashcards(userId, category)","CREATE INDEX IF NOT EXISTS idx_flashcards_difficulty ON flashcards(userId, difficulty)",`CREATE TABLE IF NOT EXISTS study_sessions (
    id TEXT PRIMARY KEY,
    userId TEXT NOT NULL,
    sessionId TEXT NOT NULL,
    sessionType TEXT,
    startTime TEXT,
    endTime TEXT,
    createdAt TEXT NOT NULL,
    updatedAt TEXT NOT NULL,
    document TEXT NOT NULL,
    UNIQUE(userId, sessionId)
  )`,"CREATE INDEX IF NOT EXISTS idx_sessions_user ON study_sessions(userId)",`CREATE TABLE IF NOT EXISTS study_statistics (
    id TEXT PRIMARY KEY,
    userId TEXT NOT NULL,
    statsId TEXT NOT NULL,
    date TEXT NOT NULL,
    createdAt TEXT NOT NULL,
    updatedAt TEXT NOT NULL,
    document TEXT NOT NULL,
    UNIQUE(userId, statsId),
    UNIQUE(userId, date)
  )`,"CREATE INDEX IF NOT EXISTS idx_statistics_user ON study_statistics(userId)","CREATE INDEX IF NOT EXISTS idx_statistics_date ON study_statistics(date)",`CREATE TABLE IF NOT EXISTS migrations (
    id TEXT PRIMARY KEY,
    version TEXT NOT NULL,
    description TEXT,
    appliedAt TEXT NOT NULL
  )`];class N{constructor(){this.initialized=!1,this.mode="local"}static getInstance(){return N.instance||(N.instance=new N),N.instance}async connect(){if(this.initialized)return!0;try{return await D.initializeSchema(re),this.mode=D.isRemote()?"remote":"local",this.initialized=!0,console.log(`Cloudflare D1 ready (mode: ${this.mode})`),!0}catch(e){const t=e instanceof Error?e.message:String(e);return console.error("Failed to initialize Cloudflare D1:",t),this.initialized=!1,!1}}isDatabaseConnected(){return this.initialized}getMode(){return this.mode}async close(){await D.close(),this.initialized=!1}async healthCheck(){try{await this.connect();const t=((await D.execute("SELECT name FROM sqlite_master WHERE type='table'")).results||[]).map(s=>typeof s.name=="string"?s.name:void 0).filter(s=>!!s);return{status:"connected",database:"cloudflare-d1",mode:this.mode,tables:t}}catch(e){const t=e instanceof Error?e.message:String(e);return{status:"error",database:"cloudflare-d1",mode:this.mode,error:t}}}}const j=N.getInstance(),ie=async()=>j.connect(),ne=async()=>{await j.close()},oe=()=>({provider:"cloudflare-d1",mode:j.getMode()}),xe={provider:"cloudflare-d1",mode:j.getMode(),database:"cloudflare-d1"},W=12;function K(d){const e=typeof globalThis<"u"?globalThis.crypto:void 0;if(e?.getRandomValues){const s=new Uint8Array(d);return e.getRandomValues(s),Array.from(s,a=>a.toString(16).padStart(2,"0")).join("")}if(e?.randomUUID)return e.randomUUID().replace(/-/g,"").slice(0,d*2);let t="";for(let s=0;s<d;s+=1){const a=Math.floor(Math.random()*256);t+=a.toString(16).padStart(2,"0")}return t}const H={users:{table:"users",filterColumns:{_id:"id",userId:"userId",email:"email",username:"username",createdAt:"createdAt",updatedAt:"updatedAt"}},flashcards:{table:"flashcards",filterColumns:{_id:"id",userId:"userId",cardId:"cardId",category:"category",difficulty:"difficulty",createdAt:"createdAt",updatedAt:"updatedAt"}},study_sessions:{table:"study_sessions",filterColumns:{_id:"id",userId:"userId",sessionId:"sessionId",sessionType:"sessionType",startTime:"startTime",endTime:"endTime"}},study_statistics:{table:"study_statistics",filterColumns:{_id:"id",userId:"userId",statsId:"statsId",date:"date",period:"period"}},migrations:{table:"migrations",filterColumns:{_id:"id",id:"id",version:"version"}}},V=/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?Z$/,ce=["createdAt","updatedAt","startTime","endTime","nextReviewDate","lastStudyDate","passwordChangedAt","passwordResetExpires","emailVerifiedAt","lastLogin","accountLockedUntil","timestamp","date","appliedAt"],de=/^[a-f0-9]{24}$/;class ue{constructor(e){if(!(e in H))throw new Error(`Unsupported collection: ${e}`);this.collectionName=e}get config(){return H[this.collectionName]}async ensureReady(){await j.connect()}generateId(){return K(W)}normalizeValue(e){return e===void 0?null:e instanceof Date?e.toISOString():Array.isArray(e)||typeof e=="object"&&e!==null?JSON.stringify(e,(t,s)=>s instanceof Date?s.toISOString():s):e}serializeDocument(e){return JSON.stringify(e,(t,s)=>s instanceof Date?s.toISOString():s)}restoreDates(e,t){if(e==null)return e;if(Array.isArray(e))return e.map(s=>this.restoreDates(s));if(typeof e=="object"){const s={};for(const[a,r]of Object.entries(e))s[a]=this.restoreDates(r,a);return s}if(typeof e=="string"&&V.test(e)&&t&&(ce.includes(t)||t.endsWith("At")||t.endsWith("Date")||t.includes("Time"))){const s=new Date(e);if(!Number.isNaN(s.getTime()))return s}return e}deserializeDocument(e){const t=JSON.parse(e);return this.restoreDates(t)}setNestedValue(e,t,s){const a=t.split(".");let r=e;for(let i=0;i<a.length-1;i++){const n=a[i],o=r[n];(typeof o!="object"||o===null||Array.isArray(o))&&(r[n]={}),r=r[n]}r[a[a.length-1]]=s}applyUpdates(e,t){for(const[s,a]of Object.entries(t))s.includes(".")?this.setNestedValue(e,s,a):e[s]=a}getColumnForField(e){const t=this.config.filterColumns[e];return t||(e==="_id"?"id":null)}getNestedValue(e,t){const s=t.split(".");let a=e;for(const r of s){if(a==null||typeof a!="object")return;a=a[r]}return a}prepareDocument(e){const t=new Date,s={...e};return s._id||(s._id=this.generateId()),s.createdAt||(s.createdAt=t),s.updatedAt=s.updatedAt?s.updatedAt:t,s}prepareRow(e){const t={id:e._id,createdAt:this.normalizeValue(e.createdAt),updatedAt:this.normalizeValue(e.updatedAt),document:this.serializeDocument(e)};for(const[s,a]of Object.entries(this.config.filterColumns)){if(a==="id"){t[a]=e._id;continue}const r=this.getNestedValue(e,s);t[a]=this.normalizeValue(r)}return t}buildInsert(e){const t=Object.keys(e),s=t.map(()=>"?").join(", "),a=`INSERT INTO ${this.config.table} (${t.join(", ")}) VALUES (${s})`,r=t.map(i=>e[i]);return{sql:a,params:r}}buildUpdate(e){const t=Object.keys(e).filter(i=>i!=="id"),s=t.map(i=>`${i} = ?`).join(", "),a=`UPDATE ${this.config.table} SET ${s} WHERE id = ?`,r=t.map(i=>e[i]);return r.push(e.id),{sql:a,params:r}}rowToDocument(e){const t=this.deserializeDocument(e.document);return t._id=t._id||e.id,e.createdAt&&(t.createdAt=this.restoreDates(e.createdAt,"createdAt")),e.updatedAt&&(t.updatedAt=this.restoreDates(e.updatedAt,"updatedAt")),t}buildWhereClause(e){const t=[],s=[],a={};for(const[i,n]of Object.entries(e||{})){const o=this.getColumnForField(i);if(!o){a[i]=n;continue}if(n&&typeof n=="object"&&!Array.isArray(n)&&!(n instanceof Date)){const c=Object.entries(n),u=["$ne","$in","$nin","$gte","$lte","$gt","$lt"];if(c.every(([m])=>u.includes(m)))for(const[m,y]of c)switch(m){case"$ne":t.push(`${o} <> ?`),s.push(this.normalizeValue(y));break;case"$in":if(Array.isArray(y)&&y.length){const w=y.map(()=>"?").join(", ");t.push(`${o} IN (${w})`),s.push(...y.map(F=>this.normalizeValue(F)))}break;case"$nin":if(Array.isArray(y)&&y.length){const w=y.map(()=>"?").join(", ");t.push(`${o} NOT IN (${w})`),s.push(...y.map(F=>this.normalizeValue(F)))}break;case"$gte":t.push(`${o} >= ?`),s.push(this.normalizeValue(y));break;case"$lte":t.push(`${o} <= ?`),s.push(this.normalizeValue(y));break;case"$gt":t.push(`${o} > ?`),s.push(this.normalizeValue(y));break;case"$lt":t.push(`${o} < ?`),s.push(this.normalizeValue(y));break}else a[i]=n;continue}n===null?t.push(`${o} IS NULL`):(t.push(`${o} = ?`),s.push(this.normalizeValue(n)))}return{clause:t.length?` WHERE ${t.join(" AND ")}`:"",params:s,fallback:a}}applyFallbackFilter(e,t){return!t||Object.keys(t).length===0?e:e.filter(s=>this.matchesFilter(s,t))}matchesFilter(e,t){for(const[s,a]of Object.entries(t)){const r=this.getNestedValue(e,s);if(a&&typeof a=="object"&&!Array.isArray(a)&&!(a instanceof Date)){const i=a;for(const[n,o]of Object.entries(i))switch(n){case"$ne":if(this.areEqual(r,o))return!1;break;case"$in":if(Array.isArray(o)&&!o.some(c=>this.areEqual(r,c)))return!1;break;case"$nin":if(Array.isArray(o)&&o.some(c=>this.areEqual(r,c)))return!1;break;case"$gte":if(!this.compare(r,o,(c,u)=>c>=u))return!1;break;case"$lte":if(!this.compare(r,o,(c,u)=>c<=u))return!1;break;case"$gt":if(!this.compare(r,o,(c,u)=>c>u))return!1;break;case"$lt":if(!this.compare(r,o,(c,u)=>c<u))return!1;break;default:if(typeof o=="object"&&o!==null&&!this.matchesFilter(r,{[n]:o}))return!1}}else if(!this.areEqual(r,a))return!1}return!0}areEqual(e,t){return e instanceof Date&&t instanceof Date?e.getTime()===t.getTime():e instanceof Date&&typeof t=="string"&&V.test(t)?e.getTime()===new Date(t).getTime():t instanceof Date&&typeof e=="string"&&V.test(e)?t.getTime()===new Date(e).getTime():JSON.stringify(e)===JSON.stringify(t)}compare(e,t,s){if(e instanceof Date||typeof e=="string"&&V.test(e)){const a=e instanceof Date?e:new Date(e),r=t instanceof Date?t:new Date(String(t));return s(a.getTime(),r.getTime())}if(typeof e=="number"||typeof e=="string"){const a=typeof t=="number"||typeof t=="string"?t:Number(t);return s(e,a)}return!1}async query(e,t={}){await this.ensureReady();const{clause:s,params:a,fallback:r}=this.buildWhereClause(e);let i=`SELECT * FROM ${this.config.table}${s}`;if(t.sort&&Object.keys(t.sort).length>0){const u=[];for(const[m,y]of Object.entries(t.sort)){const w=this.getColumnForField(m);w&&u.push(`${w} ${y===-1?"DESC":"ASC"}`)}u.length&&(i+=` ORDER BY ${u.join(", ")}`)}typeof t.limit=="number"&&(i+=` LIMIT ${t.limit}`),typeof t.skip=="number"&&(i.includes("LIMIT")||(i+=" LIMIT -1"),i+=` OFFSET ${t.skip}`);const c=((await D.execute(i,a)).results||[]).map(u=>this.rowToDocument(u));return this.applyFallbackFilter(c,r)}async create(e){const t=Date.now();try{const s=this.prepareDocument(e),a=this.prepareRow(s),{sql:r,params:i}=this.buildInsert(a),n=await D.execute(r,i);if(!n.success)throw new Error(n.error||"Failed to insert document");return{success:!0,data:s,operationTime:Date.now()-t}}catch(s){return{success:!1,error:s instanceof Error?s.message:String(s),operationTime:Date.now()-t}}}async findOne(e,t){const s=Date.now();try{const a=await this.query(e,{...t,limit:1});return{success:!0,data:a.length?a[0]:null,operationTime:Date.now()-s}}catch(a){return{success:!1,error:a instanceof Error?a.message:String(a),operationTime:Date.now()-s}}}async findMany(e={},t){const s=Date.now();try{return{success:!0,data:await this.query(e,t),operationTime:Date.now()-s}}catch(a){return{success:!1,error:a instanceof Error?a.message:String(a),operationTime:Date.now()-s}}}async updateOne(e,t,s={}){const a=Date.now();try{const r=await this.findOne(e);if(!r.success)return r;if(!r.data){if(s.upsert){const m={};for(const[w,F]of Object.entries(e))(typeof F!="object"||F instanceof Date||Array.isArray(F))&&(m[w]=F);const y={...m,...t.$set||t};return this.create(y)}return{success:!0,data:null,operationTime:Date.now()-a}}const i={...r.data,updatedAt:new Date};this.applyUpdates(i,t.$set||t);const n=this.prepareRow(i),{sql:o,params:c}=this.buildUpdate(n),u=await D.execute(o,c);if(!u.success)throw new Error(u.error||"Failed to update document");return{success:!0,data:i,operationTime:Date.now()-a}}catch(r){return{success:!1,error:r instanceof Error?r.message:String(r),operationTime:Date.now()-a}}}async updateMany(e,t){const s=Date.now();try{const a=await this.query(e);let r=0;for(const i of a){const n={...i,updatedAt:new Date};this.applyUpdates(n,t.$set||t);const o=this.prepareRow(n),{sql:c,params:u}=this.buildUpdate(o);(await D.execute(c,u)).success&&r++}return{success:!0,data:{modifiedCount:r},operationTime:Date.now()-s}}catch(a){return{success:!1,error:a instanceof Error?a.message:String(a),operationTime:Date.now()-s}}}async deleteOne(e){const t=Date.now();try{const s=await this.findOne(e);if(!s.success)return{success:!1,error:s.error,operationTime:Date.now()-t};if(!s.data)return{success:!0,data:{deletedCount:0},operationTime:Date.now()-t};const a=`DELETE FROM ${this.config.table} WHERE id = ?`,r=await D.execute(a,[s.data._id]);if(!r.success)throw new Error(r.error||"Failed to delete document");return{success:!0,data:{deletedCount:1},operationTime:Date.now()-t}}catch(s){return{success:!1,error:s instanceof Error?s.message:String(s),operationTime:Date.now()-t}}}async deleteMany(e){const t=Date.now();try{const s=await this.query(e);let a=0;for(const r of s){const i=`DELETE FROM ${this.config.table} WHERE id = ?`;(await D.execute(i,[r._id])).success&&a++}return{success:!0,data:{deletedCount:a},operationTime:Date.now()-t}}catch(s){return{success:!1,error:s instanceof Error?s.message:String(s),operationTime:Date.now()-t}}}async count(e={}){const t=Date.now();try{const{clause:s,params:a}=this.buildWhereClause(e),r=`SELECT COUNT(*) as count FROM ${this.config.table}${s}`,i=await D.execute(r,a),n=i.results&&i.results[0]&&i.results[0].count||0;return{success:!0,data:typeof n=="number"?n:Number(n),operationTime:Date.now()-t}}catch(s){return{success:!1,error:s instanceof Error?s.message:String(s),operationTime:Date.now()-t}}}async exists(e){const t=await this.count(e);return t.success?{success:!0,data:(t.data||0)>0,operationTime:t.operationTime}:{success:!1,error:t.error,operationTime:t.operationTime}}async bulkWrite(e){const t=Date.now(),s={success:!0,insertedCount:0,updatedCount:0,deletedCount:0,errors:[],operationTime:0};for(const a of e)try{if(a.insertOne){const{document:r}=a.insertOne,i=await this.create(r);if(!i.success)throw new Error(i.error||"Insert failed");s.insertedCount++}else if(a.updateOne){const{filter:r,update:i,options:n}=a.updateOne,o=await this.updateOne(r,i,n);if(!o.success)throw new Error(o.error||"Update failed");o.data&&s.updatedCount++}else if(a.deleteOne){const{filter:r}=a.deleteOne,i=await this.deleteOne(r);if(!i.success)throw new Error(i.error||"Delete failed");s.deletedCount+=i.data?.deletedCount||0}}catch(r){const i=r instanceof Error?r.message:String(r);s.errors.push(i),s.success=!1}return s.operationTime=Date.now()-t,{success:s.errors.length===0,data:s,error:s.errors.length?s.errors.join("; "):void 0,operationTime:s.operationTime}}async aggregate(){return{success:!1,error:"Aggregation pipelines are not supported in the D1 adapter",operationTime:0}}async createIndexes(){return{success:!0,data:[],operationTime:0}}async distinct(e,t={}){const s=Date.now();try{const a=await this.findMany(t);if(!a.success||!a.data)throw new Error(a.error||"Failed to retrieve documents for distinct query");const r=new Set;for(const i of a.data){const n=this.getNestedValue(i,e);n!=null&&(Array.isArray(n)?n.forEach(o=>r.add(o)):r.add(n))}return{success:!0,data:Array.from(r),operationTime:Date.now()-s}}catch(a){return{success:!1,error:a instanceof Error?a.message:String(a),operationTime:Date.now()-s}}}}function L(d){return new ue(d)}const le={isValidObjectId(d){return de.test(d)},toObjectId(d){if(!this.isValidObjectId(d))throw new Error(`Invalid identifier: ${d}`);return d},generateId(){return K(W)},idToString(d){return d},validateDocument(d,e){for(const t of e)if(!(t in d)||d[t]===null||d[t]===void 0)return new Error(`Missing required field: ${t}`);return null}},pe=/^[a-f0-9]{24}$/;var me=(d=>(d.USERS="users",d.FLASHCARDS="flashcards",d.STUDY_SESSIONS="study_sessions",d.CARD_PROGRESS="card_progress",d.STUDY_STATISTICS="study_statistics",d))(me||{});class p extends Error{constructor(e,t="DATABASE_ERROR",s="unknown",a,r){super(e),this.name="DatabaseError",this.code=t,this.operation=s,this.collection=a,this.timestamp=new Date,this.details=r,Error.captureStackTrace&&Error.captureStackTrace(this,p)}toJSON(){return{name:this.name,message:this.message,code:this.code,operation:this.operation,collection:this.collection,timestamp:this.timestamp.toISOString(),details:this.details,stack:this.stack}}}class ye extends p{constructor(e,t="connect",s){super(e,"CONNECTION_ERROR",t,void 0,s),this.name="ConnectionError"}}class T extends p{constructor(e,t="validate",s,a,r,i){super(e,"VALIDATION_ERROR",t,s,i),this.name="ValidationError",this.field=a,this.value=r}}class k extends p{constructor(e,t="find",s,a,r){super(e,"NOT_FOUND_ERROR",t,s,r),this.name="NotFoundError",this.documentId=a}}class $ extends p{constructor(e,t="insert",s,a,r,i){super(e,"DUPLICATE_ERROR",t,s,i),this.name="DuplicateError",this.field=a,this.value=r}}class fe extends p{constructor(e,t="authorize",s,a,r,i){super(e,"PERMISSION_ERROR",t,s,i),this.name="PermissionError",this.userId=a,this.requiredPermission=r}}class $e extends p{constructor(e,t="rate_limit",s,a){super(e,"RATE_LIMIT_ERROR",t,void 0,a),this.name="RateLimitError",this.retryAfter=s}}class J extends p{constructor(e,t="sm2_calculation",s="flashcards",a,r,i){super(e,"SM2_ERROR",t,s,i),this.name="SM2Error",this.quality=a,this.currentInterval=r}}class he extends p{constructor(e,t="bulk_operation",s,a=0,r=0,i=[],n){super(e,"BULK_OPERATION_ERROR",t,s,n),this.name="BulkOperationError",this.successfulCount=a,this.failedCount=r,this.errors=i}}class Me extends p{constructor(e,t="migration",s,a,r){super(e,"MIGRATION_ERROR",t,void 0,r),this.name="MigrationError",this.migrationId=s,this.version=a}}const ge={logErrors:!0,throwOnError:!0,includeStackTrace:!1};class Q{constructor(e={}){this.config={...ge,...e}}handle(e,t){let s;if(e instanceof p?s=e:e.name==="MongoError"||e.name==="MongoServerError"?s=this.handleMongoError(e,t):s=new p(e.message,"UNKNOWN_ERROR",t?.operation||"unknown",t?.collection,{originalError:e}),t){const a=s;a.details={...s.details,context:{operation:t.operation,collection:t.collection,userId:t.userId,documentId:t.documentId}}}if(this.config.logErrors&&this.logError(s),this.config.throwOnError)throw s;return s}handleMongoError(e,t){const{operation:s,collection:a}=t||{};if(e.code===11e3){const r=Object.keys(e.keyPattern||{})[0],i=Object.values(e.keyValue||{})[0];return new $(`Duplicate value for field '${r}': ${i}`,s,a,r,i,{originalError:e})}return e.name==="MongoNetworkError"||e.name==="MongoTimeoutError"?new ye(`Database connection error: ${e.message}`,s,{originalError:e}):e.name==="ValidationError"?new T(`Validation failed: ${e.message}`,s,a,void 0,void 0,{originalError:e}):new p(e.message,`MONGODB_ERROR_${e.code||"UNKNOWN"}`,s||"unknown",a,{originalError:e})}logError(e){if(this.config.customLogger)this.config.customLogger(e);else{const t=this.config.includeStackTrace?e.toJSON():{name:e.name,message:e.message,code:e.code,operation:e.operation,collection:e.collection,timestamp:e.timestamp.toISOString(),details:e.details};console.error("[Database Error]",JSON.stringify(t,null,2))}}static createUserMessage(e){switch(e.code){case"CONNECTION_ERROR":return"Unable to connect to the database. Please check your internet connection and try again.";case"VALIDATION_ERROR":return"The provided data is invalid. Please check your input and try again.";case"NOT_FOUND_ERROR":return"The requested item was not found.";case"DUPLICATE_ERROR":return"This item already exists. Please use a different value.";case"PERMISSION_ERROR":return"You do not have permission to perform this action.";case"RATE_LIMIT_ERROR":return"Too many requests. Please wait a moment and try again.";case"SM2_ERROR":return"There was an error processing your study progress. Please try again.";default:return"An unexpected error occurred. Please try again."}}}async function l(d,e){try{return await d()}catch(t){throw new Q().handle(t,e),t}}function Se(d,e="id"){if(!pe.test(d))throw new T(`Invalid ObjectId format for field '${e}': ${d}`,"validate_object_id",void 0,e,d)}function z(d,e,t){const s=e.filter(a=>{const r=d[a];return r==null||r===""});if(s.length>0)throw new T(`Missing required fields: ${s.join(", ")}`,"validate_required_fields",t,s[0])}function Z(d){if(!Number.isInteger(d)||d<0||d>5)throw new J(`Invalid quality value: ${d}. Must be an integer between 0 and 5.`,"validate_quality","flashcards",d)}function U(d,e,t,s){if(typeof d!="string")throw new T("Invalid document owner identifier","validate_ownership",t,"userId",d,{documentId:s,requestUserId:e});if(d!==e)throw new fe("Access denied: You do not own this resource","validate_ownership",t,e,"owner",{documentId:s,documentUserId:d,requestUserId:e})}const Te=new Q,q={validator:{$jsonSchema:{bsonType:"object",required:["userId","preferences","statistics","authentication","createdAt","updatedAt"],properties:{userId:{bsonType:"string",description:"Unique user identifier"},email:{bsonType:["string","null"],description:"User email address",pattern:"^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$"},username:{bsonType:["string","null"],description:"Unique username",maxLength:30},preferences:{bsonType:"object",required:["theme","language","audioEnabled","studyReminders"],properties:{theme:{enum:["light","dark","auto"],description:"UI theme preference"},language:{bsonType:"string",description:"Preferred language"},audioEnabled:{bsonType:"bool",description:"Audio features enabled"},studyReminders:{bsonType:"bool",description:"Study reminder notifications"},dailyCardLimit:{bsonType:"int",minimum:5,maximum:200,description:"Daily card study limit"},sessionDuration:{bsonType:"int",minimum:5,maximum:120,description:"Default session duration in minutes"}}},statistics:{bsonType:"object",required:["totalCardsStudied","totalStudyTime","averageRecallRate","streakDays"],properties:{totalCardsStudied:{bsonType:"int",minimum:0,description:"Total cards studied"},totalStudyTime:{bsonType:"int",minimum:0,description:"Total study time in minutes"},averageRecallRate:{bsonType:"double",minimum:0,maximum:100,description:"Average recall rate percentage"},streakDays:{bsonType:"int",minimum:0,description:"Current study streak in days"},lastStudyDate:{bsonType:["date","null"],description:"Last study session date"},cardsMastered:{bsonType:"int",minimum:0,description:"Cards with high repetition count"},totalSessions:{bsonType:"int",minimum:0,description:"Total study sessions completed"}}},profile:{bsonType:"object",properties:{avatar:{bsonType:"string",description:"User avatar URL"},bio:{bsonType:"string",maxLength:500,description:"User biography"},timezone:{bsonType:"string",description:"User timezone"},joinDate:{bsonType:"date",description:"Account creation date"}}},authentication:{bsonType:"object",required:["password","emailVerified"],properties:{password:{bsonType:"string",minLength:60,maxLength:100,description:"Hashed password using bcrypt (60+ chars for bcrypt hash)"},passwordChangedAt:{bsonType:"date",description:"Last password change timestamp"},passwordResetToken:{bsonType:["string","null"],description:"Password reset token"},passwordResetExpires:{bsonType:["date","null"],description:"Password reset token expiration"},emailVerificationToken:{bsonType:["string","null"],description:"Email verification token"},emailVerified:{bsonType:"bool",description:"Email verification status"},emailVerifiedAt:{bsonType:["date","null"],description:"Email verification timestamp"},refreshTokens:{bsonType:"array",items:{bsonType:"object",properties:{token:{bsonType:"string",description:"Refresh token"},createdAt:{bsonType:"date",description:"Token creation timestamp"},expiresAt:{bsonType:"date",description:"Token expiration timestamp"},deviceInfo:{bsonType:"string",description:"Device/browser information"},ipAddress:{bsonType:"string",description:"IP address used for token creation"}}},description:"Active refresh tokens"}}},security:{bsonType:"object",properties:{lastLogin:{bsonType:"date",description:"Last login timestamp"},lastLoginIP:{bsonType:"string",description:"IP address of last login"},loginAttempts:{bsonType:"int",minimum:0,description:"Failed login attempts"},accountLocked:{bsonType:"bool",description:"Account lock status"},accountLockedUntil:{bsonType:["date","null"],description:"Account lock expiration"},suspiciousActivity:{bsonType:"array",items:{bsonType:"object",properties:{type:{bsonType:"string",description:"Type of suspicious activity"},timestamp:{bsonType:"date",description:"Activity timestamp"},ipAddress:{bsonType:"string",description:"IP address of activity"},details:{bsonType:"string",description:"Additional details"}}},description:"Suspicious activity log"}}},createdAt:{bsonType:"date",description:"Document creation timestamp"},updatedAt:{bsonType:"date",description:"Document last update timestamp"},version:{bsonType:"int",minimum:1,description:"Schema version for migrations"}}}}},P={validator:{$jsonSchema:{bsonType:"object",required:["cardId","userId","front","back","category","sm2","createdAt","updatedAt"],properties:{cardId:{bsonType:"string",description:"Unique card identifier"},userId:{bsonType:"string",description:"Owner user ID"},front:{bsonType:"string",maxLength:1e3,description:"Card front content"},back:{bsonType:"string",maxLength:1e3,description:"Card back content"},exampleFront:{bsonType:["string","null"],maxLength:1e3,description:"Example sentence in front language"},exampleBack:{bsonType:["string","null"],maxLength:1e3,description:"Example sentence in back language"},audioUrl:{bsonType:["string","null"],description:"Pronunciation audio URL",pattern:"^https?://.+"},imageUrl:{bsonType:["string","null"],description:"Illustrative image URL",pattern:"^https?://.+"},tags:{bsonType:"array",items:{bsonType:"string",maxLength:50},description:"Card tags for organization"},category:{bsonType:"string",maxLength:100,description:"Card category"},difficulty:{enum:["easy","medium","hard"],description:"Perceived difficulty level"},metadata:{bsonType:"object",properties:{source:{bsonType:"string",maxLength:200,description:"Content source"},createdByAI:{bsonType:"bool",description:"Generated by AI"},aiModel:{bsonType:"string",maxLength:100,description:"AI model used for generation"},confidence:{bsonType:"double",minimum:0,maximum:1,description:"AI confidence score"}}},sm2:{bsonType:"object",required:["easeFactor","interval","repetitions","nextReviewDate"],properties:{easeFactor:{bsonType:"double",minimum:1.3,maximum:2.5,description:"SM-2 ease factor"},interval:{bsonType:"int",minimum:1,description:"Current interval in days"},repetitions:{bsonType:"int",minimum:0,description:"Successful recalls in a row"},nextReviewDate:{bsonType:"date",description:"Next review due date"},lastReviewed:{bsonType:["date","null"],description:"Last review timestamp"},qualityResponses:{bsonType:"array",items:{bsonType:"int",minimum:0,maximum:5},description:"Historical quality responses"},totalReviews:{bsonType:"int",minimum:0,description:"Total review attempts"},correctStreak:{bsonType:"int",minimum:0,description:"Current correct answers streak"},incorrectStreak:{bsonType:"int",minimum:0,description:"Current incorrect answers streak"},isSuspended:{bsonType:"bool",description:"Card temporarily suspended"},suspensionReason:{bsonType:"string",maxLength:200,description:"Reason for suspension"}}},statistics:{bsonType:"object",properties:{timesCorrect:{bsonType:"int",minimum:0,description:"Total correct responses"},timesIncorrect:{bsonType:"int",minimum:0,description:"Total incorrect responses"},averageResponseTime:{bsonType:"double",minimum:0,description:"Average response time in seconds"},lastDifficulty:{enum:["easy","medium","hard"],description:"Last reported difficulty"}}},createdAt:{bsonType:"date",description:"Card creation timestamp"},updatedAt:{bsonType:"date",description:"Card last update timestamp"},version:{bsonType:"int",minimum:1,description:"Schema version"}}}}},ee={validator:{$jsonSchema:{bsonType:"object",required:["sessionId","userId","startTime","cardsStudied","createdAt","updatedAt"],properties:{sessionId:{bsonType:"string",description:"Unique session identifier"},userId:{bsonType:"string",description:"User who conducted the session"},startTime:{bsonType:"date",description:"Session start timestamp"},endTime:{bsonType:["date","null"],description:"Session end timestamp"},duration:{bsonType:"int",minimum:0,description:"Session duration in seconds"},cardsStudied:{bsonType:"array",items:{bsonType:"object",required:["cardId","quality","wasCorrect"],properties:{cardId:{bsonType:"string",description:"Card identifier"},quality:{bsonType:"int",minimum:0,maximum:5,description:"Quality of response (0-5)"},responseTime:{bsonType:"double",minimum:0,description:"Response time in seconds"},wasCorrect:{bsonType:"bool",description:"Whether response was correct"},previousEaseFactor:{bsonType:"double",description:"Ease factor before this review"},newEaseFactor:{bsonType:"double",description:"Ease factor after this review"},previousInterval:{bsonType:"int",description:"Interval before this review"},newInterval:{bsonType:"int",description:"Interval after this review"}}},description:"Cards studied in this session"},totalCards:{bsonType:"int",minimum:0,description:"Total cards in session"},correctAnswers:{bsonType:"int",minimum:0,description:"Number of correct answers"},incorrectAnswers:{bsonType:"int",minimum:0,description:"Number of incorrect answers"},averageResponseTime:{bsonType:"double",minimum:0,description:"Average response time"},sessionType:{enum:["review","new","practice","difficult","custom"],description:"Type of study session"},config:{bsonType:"object",properties:{dailyLimit:{bsonType:"int",minimum:1,description:"Daily card limit"},sessionLimit:{bsonType:"int",minimum:1,description:"Session card limit"},difficultyFilter:{bsonType:"object",properties:{enabled:{bsonType:"bool"},levels:{bsonType:"array",items:{enum:["easy","medium","hard"]}}}},mode:{enum:["review-only","new-only","mixed","difficult-cards"]}}},performance:{bsonType:"object",properties:{overallScore:{bsonType:"double",minimum:0,maximum:100,description:"Overall session score"},improvement:{bsonType:"double",description:"Improvement from previous sessions"},focusAreas:{bsonType:"array",items:{bsonType:"string",maxLength:100},description:"Areas needing focus"},retentionRate:{bsonType:"double",minimum:0,maximum:100,description:"Session retention rate"},consistency:{bsonType:"double",minimum:0,maximum:100,description:"Response consistency score"}}},interruptions:{bsonType:"array",items:{bsonType:"object",required:["type","startTime"],properties:{type:{enum:["pause","break","distraction"]},startTime:{bsonType:"date"},endTime:{bsonType:"date"},duration:{bsonType:"int",minimum:0},reason:{bsonType:"string",maxLength:200}}},description:"Session interruptions"},createdAt:{bsonType:"date",description:"Session creation timestamp"},updatedAt:{bsonType:"date",description:"Session last update timestamp"},version:{bsonType:"int",minimum:1,description:"Schema version"}}}}},X={validator:{$jsonSchema:{bsonType:"object",required:["statsId","userId","date","period","dailyStats","createdAt","updatedAt"],properties:{statsId:{bsonType:"string",description:"Unique statistics identifier"},userId:{bsonType:"string",description:"User identifier"},date:{bsonType:"date",description:"Statistics date"},period:{enum:["daily","weekly","monthly"],description:"Statistics period type"},dailyStats:{bsonType:"object",required:["cardsStudied","studyTime","correctAnswers","incorrectAnswers","averageRecallRate"],properties:{cardsStudied:{bsonType:"int",minimum:0},studyTime:{bsonType:"int",minimum:0,description:"Study time in minutes"},correctAnswers:{bsonType:"int",minimum:0},incorrectAnswers:{bsonType:"int",minimum:0},averageRecallRate:{bsonType:"double",minimum:0,maximum:100},averageResponseTime:{bsonType:"double",minimum:0},sessionsCompleted:{bsonType:"int",minimum:0},newCardsLearned:{bsonType:"int",minimum:0}}},weeklyStats:{bsonType:"object",properties:{totalCards:{bsonType:"int",minimum:0},totalTime:{bsonType:"int",minimum:0},averageRate:{bsonType:"double",minimum:0,maximum:100},improvement:{bsonType:"double"},streakDays:{bsonType:"int",minimum:0},categoriesStudied:{bsonType:"array",items:{bsonType:"object",properties:{category:{bsonType:"string"},cardsCount:{bsonType:"int",minimum:0}}}}}},monthlyStats:{bsonType:"object",properties:{totalCards:{bsonType:"int",minimum:0},totalTime:{bsonType:"int",minimum:0},averageRate:{bsonType:"double",minimum:0,maximum:100},improvement:{bsonType:"double"},mostStudiedCategory:{bsonType:"string"},leastStudiedCategory:{bsonType:"string"},consistency:{bsonType:"double",minimum:0,maximum:100}}},createdAt:{bsonType:"date"},updatedAt:{bsonType:"date"},version:{bsonType:"int",minimum:1}}}}},we={validator:{$jsonSchema:{bsonType:"object",required:["migrationId","version","description","appliedAt"],properties:{migrationId:{bsonType:"string",description:"Unique migration identifier"},version:{bsonType:"string",description:"Schema version"},description:{bsonType:"string",description:"Migration description"},appliedAt:{bsonType:"date",description:"Migration application timestamp"},checksum:{bsonType:"string",description:"Migration checksum for validation"},success:{bsonType:"bool",description:"Migration success status"},error:{bsonType:"string",description:"Migration error message"}}}}},je={UserSchema:q,FlashcardSchema:P,StudySessionSchema:ee,StudyStatisticsSchema:X,MigrationSchema:we},_e=function(d){return!d||typeof d!="string"?!0:/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(d)},G=function(d){return!d||typeof d!="string"?!0:/^https?:\/\/.+/.test(d)},ze=function(d){return d>=0&&d<=5};function A(d){return typeof d!="string"?"":d.trim().replace(/[<>]/g,"")}const be=function(d){if(!d)return!0;const{easeFactor:e,interval:t,repetitions:s}=d;return!(e!==void 0&&(e<1.3||e>2.5)||t!==void 0&&t<1||s!==void 0&&s<0)};function Ve(d){const{quality:e,easeFactor:t,interval:s}=d;return e>=0&&e<=5&&t>=1.3&&t<=2.5&&s>=1}function te(){return{easeFactor:2.5,interval:1,repetitions:0,nextReviewDate:new Date}}function Y(d,e,t){let s;t>=3?d===1?s=6:s=Math.round(d*e):s=1;const a=new Date;return a.setDate(a.getDate()+s),a}function O(d,e){const t=[];try{const s=e.validator?.$jsonSchema?.required;if(s&&Array.isArray(s))for(const a of s)(!(a in d)||d[a]===null||d[a]===void 0)&&t.push(`Missing required field: ${a}`);return d.sm2&&!be(d.sm2)&&t.push("Invalid SM-2 parameters"),d.email&&!_e(d.email)&&t.push("Invalid email format"),d.audioUrl&&!G(d.audioUrl)&&t.push("Invalid audio URL format"),d.imageUrl&&!G(d.imageUrl)&&t.push("Invalid image URL format"),{isValid:t.length===0,errors:t}}catch(s){return{isValid:!1,errors:[`Validation error: ${s instanceof Error?s.message:"Unknown error"}`]}}}const Pe={users:[{key:{userId:1},options:{unique:!0}},{key:{email:1},options:{unique:!0,sparse:!0}},{key:{username:1},options:{unique:!0,sparse:!0}},{key:{"statistics.totalCardsStudied":-1}},{key:{"statistics.averageRecallRate":-1}},{key:{"statistics.streakDays":-1}},{key:{userId:1,updatedAt:-1}}],flashcards:[{key:{userId:1,cardId:1},options:{unique:!0}},{key:{userId:1,"sm2.nextReviewDate":1,"sm2.isSuspended":1}},{key:{userId:1,category:1}},{key:{userId:1,tags:1}},{key:{userId:1,difficulty:1}},{key:{userId:1,"sm2.repetitions":-1}},{key:{userId:1,"statistics.timesCorrect":-1}},{key:{userId:1,createdAt:-1}},{key:{userId:1,updatedAt:-1}},{key:{userId:1,front:"text",back:"text",exampleFront:"text",exampleBack:"text"}}],study_sessions:[{key:{userId:1,sessionId:1},options:{unique:!0}},{key:{userId:1,startTime:-1}},{key:{userId:1,endTime:-1}},{key:{userId:1,sessionType:1,startTime:-1}},{key:{userId:1,"performance.overallScore":-1}},{key:{userId:1,startTime:-1,sessionType:1}}],study_statistics:[{key:{userId:1,statsId:1},options:{unique:!0}},{key:{userId:1,date:-1,period:1}},{key:{userId:1,"dailyStats.averageRecallRate":-1}},{key:{userId:1,"dailyStats.cardsStudied":-1}}]},f="users",b=L(f);class Ee{async createUser(e){return l(async()=>{z(e,["userId","preferences","statistics","authentication"],f);const t=this.sanitizeUserData(e),s=new Date,a={...t,createdAt:s,updatedAt:s},r=O(a,q);if(!r.isValid)throw new T(`User validation failed: ${r.errors.join(", ")}`,"create_user",f);await this.checkForDuplicates(t.userId,t.email);const i=await b.create(t);if(!i.success)throw new p(i.error||"Failed to create user","CREATE_USER_FAILED","create_user",f);return i},{operation:"create_user",collection:f})}async getUserById(e){return l(async()=>{if(!e)throw new T("User ID is required","get_user_by_id",f,"userId");const t=await b.findOne({userId:e});if(!t.success)throw new p(t.error||"Failed to retrieve user","GET_USER_FAILED","get_user_by_id",f);if(!t.data)throw new k(`User with ID ${e} not found`,"get_user_by_id",f,e);return t},{operation:"get_user_by_id",collection:f,userId:e})}async getUserByEmail(e){return l(async()=>{if(!e)throw new T("Email is required","get_user_by_email",f,"email");const t=await b.findOne({email:e});if(!t.success)throw new p(t.error||"Failed to retrieve user","GET_USER_FAILED","get_user_by_email",f);if(!t.data)throw new k(`User with email ${e} not found`,"get_user_by_email",f,e);return t},{operation:"get_user_by_email",collection:f})}async updateUser(e,t,s){return l(async()=>{U(e,s,f);const a=await this.getUserById(e);if(!a.success||!a.data)throw new k(`User with ID ${e} not found`,"update_user",f,e);const r=this.sanitizeUserData(t),i={...a.data,...r},n=O(i,q);if(!n.isValid)throw new T(`User validation failed: ${n.errors.join(", ")}`,"update_user",f);r.email&&r.email!==a.data.email&&await this.checkForDuplicates(e,r.email);const o=await b.updateOne({userId:e},{$set:r});if(!o.success)throw new p(o.error||"Failed to update user","UPDATE_USER_FAILED","update_user",f);return this.getUserById(e)},{operation:"update_user",collection:f,userId:e})}async updateUserPreferences(e,t,s){return l(async()=>{U(e,s,f);const a=this.validatePreferences(t),r=await b.updateOne({userId:e},{$set:{preferences:a}});if(!r.success)throw new p(r.error||"Failed to update user preferences","UPDATE_PREFERENCES_FAILED","update_user_preferences",f);return this.getUserById(e)},{operation:"update_user_preferences",collection:f,userId:e})}async updateUserStatistics(e,t){return l(async()=>{const s=this.validateStatistics(t),a=await b.updateOne({userId:e},{$set:{statistics:s,"statistics.lastStudyDate":new Date}});if(!a.success)throw new p(a.error||"Failed to update user statistics","UPDATE_STATISTICS_FAILED","update_user_statistics",f);return this.getUserById(e)},{operation:"update_user_statistics",collection:f,userId:e})}async deleteUser(e,t){return l(async()=>{U(e,t,f);const s=await b.deleteOne({userId:e});if(!s.success)throw new p(s.error||"Failed to delete user","DELETE_USER_FAILED","delete_user",f);return s},{operation:"delete_user",collection:f,userId:e})}async searchUsers(e,t={}){return l(async()=>{const s={};e.userId&&(s.userId=e.userId),e.email&&(s.email=new RegExp(e.email,"i")),e.username&&(s.username=new RegExp(e.username,"i"));const a={limit:t.limit||50,skip:t.skip||0,sort:t.sort||{createdAt:-1}},r=await b.findMany(s,a);if(!r.success)throw new p(r.error||"Failed to search users","SEARCH_USERS_FAILED","search_users",f);return r},{operation:"search_users",collection:f})}async getUserCount(e={}){return l(async()=>{const t={};e.userId&&(t.userId=e.userId),e.email&&(t.email=new RegExp(e.email,"i")),e.username&&(t.username=new RegExp(e.username,"i"));const s=await b.count(t);if(!s.success)throw new p(s.error||"Failed to count users","COUNT_USERS_FAILED","get_user_count",f);return s},{operation:"get_user_count",collection:f})}async updateUserSecurity(e,t){return l(async()=>{const s=this.validateSecurity(t),a=await b.updateOne({userId:e},{$set:{security:s}});if(!a.success)throw new p(a.error||"Failed to update user security","UPDATE_SECURITY_FAILED","update_user_security",f);return this.getUserById(e)},{operation:"update_user_security",collection:f,userId:e})}sanitizeUserData(e){const t={...e};return t.email&&(t.email=A(t.email)),t.username&&(t.username=A(t.username)),t}async checkForDuplicates(e,t){const s=await b.findOne({userId:e});if(s.success&&s.data)throw new $(`User with ID ${e} already exists`,"create_user",f,"userId",e);if(t){const a=await b.findOne({email:t});if(a.success&&a.data)throw new $(`User with email ${t} already exists`,"create_user",f,"email",t)}}validatePreferences(e){const t={theme:"light",language:"en",audioEnabled:!0,studyReminders:!0,dailyCardLimit:void 0,sessionDuration:void 0,...e};if(!["light","dark","auto"].includes(t.theme))throw new T(`Invalid theme: ${t.theme}`,"validate_preferences",f,"theme");if(t.dailyCardLimit!==void 0&&(t.dailyCardLimit<5||t.dailyCardLimit>200))throw new T("Daily card limit must be between 5 and 200","validate_preferences",f,"dailyCardLimit");if(t.sessionDuration!==void 0&&(t.sessionDuration<5||t.sessionDuration>120))throw new T("Session duration must be between 5 and 120 minutes","validate_preferences",f,"sessionDuration");return t}validateStatistics(e){const t={totalCardsStudied:0,totalStudyTime:0,averageRecallRate:0,streakDays:0,...e},s=["totalCardsStudied","totalStudyTime","streakDays"];for(const a of s)if(t[a]<0)throw new T(`${a} cannot be negative`,"validate_statistics",f,a);if(t.averageRecallRate<0||t.averageRecallRate>100)throw new T("Average recall rate must be between 0 and 100","validate_statistics",f,"averageRecallRate");return t}validateSecurity(e){const t={...e};if(t.loginAttempts!==void 0&&t.loginAttempts<0)throw new T("Login attempts cannot be negative","validate_security",f,"loginAttempts");return t}}const M=new Ee,h="flashcards",E=L(h);class De{async createFlashcard(e,t){return l(async()=>{U(e.userId,t,h),z(e,["cardId","userId","front","back","category"],h);const s=this.sanitizeCardData(e),a=te(),i={...s,sm2:a,statistics:{timesCorrect:0,timesIncorrect:0,averageResponseTime:0,lastDifficulty:"medium"}},n=O(i,P);if(!n.isValid)throw new T(`Flashcard validation failed: ${n.errors.join(", ")}`,"create_flashcard",h);await this.checkForDuplicateCard(s.userId,s.cardId);const o=await E.create(i);if(!o.success)throw new p(o.error||"Failed to create flashcard","CREATE_FLASHCARD_FAILED","create_flashcard",h);return o},{operation:"create_flashcard",collection:h,userId:t})}async getFlashcardById(e,t){return l(async()=>{const s=await E.findOne({cardId:e,userId:t});if(!s.success)throw new p(s.error||"Failed to retrieve flashcard","GET_FLASHCARD_FAILED","get_flashcard_by_id",h);if(!s.data)throw new k(`Flashcard with ID ${e} not found`,"get_flashcard_by_id",h,e);return s},{operation:"get_flashcard_by_id",collection:h,userId:t})}async updateFlashcard(e,t,s){return l(async()=>{const a=await this.getFlashcardById(e,s);if(!a.success||!a.data)throw new k(`Flashcard with ID ${e} not found`,"update_flashcard",h,e);const r=this.sanitizeCardData(t),i={...a.data,...r},n=O(i,P);if(!n.isValid)throw new T(`Flashcard validation failed: ${n.errors.join(", ")}`,"update_flashcard",h);const o=await E.updateOne({cardId:e,userId:s},{$set:r});if(!o.success)throw new p(o.error||"Failed to update flashcard","UPDATE_FLASHCARD_FAILED","update_flashcard",h);return this.getFlashcardById(e,s)},{operation:"update_flashcard",collection:h,userId:s})}async processReviewResponse(e,t,s,a){return l(async()=>{Z(t);const r=await this.getFlashcardById(e,a);if(!r.success||!r.data)throw new k(`Flashcard with ID ${e} not found`,"process_review_response",h,e);const i=r.data,n=this.calculateNewSM2Params(i.sm2,t),o=this.updateCardStatistics(i.statistics,t,s),c={sm2:{...n,lastReviewed:new Date,qualityResponses:[...i.sm2.qualityResponses||[],t],totalReviews:(i.sm2.totalReviews||0)+1},statistics:o},u=await E.updateOne({cardId:e,userId:a},{$set:c});if(!u.success)throw new J(u.error||"Failed to process review response","process_review_response",h,t);return this.getFlashcardById(e,a)},{operation:"process_review_response",collection:h,userId:a})}async getDueFlashcards(e,t={}){return l(async()=>{const s=new Date,a={userId:e};t.category&&(a.category=t.category),t.difficulty&&(a.difficulty=t.difficulty);const r=t.includeSuspended?Math.max(t.limit||50,500):t.limit||50,i=await E.findMany(a,{limit:r,sort:{createdAt:-1}});if(!i.success)throw new p(i.error||"Failed to retrieve due flashcards","GET_DUE_FLASHCARDS_FAILED","get_due_flashcards",h);return{success:!0,data:(i.data||[]).filter(c=>!!c).filter(c=>{const u=c.sm2;return!u||!(u.nextReviewDate instanceof Date)?!1:u.isSuspended?t.includeSuspended:u.nextReviewDate.getTime()<=s.getTime()}).sort((c,u)=>c.sm2.nextReviewDate.getTime()-u.sm2.nextReviewDate.getTime()).slice(0,t.limit||50),operationTime:i.operationTime}},{operation:"get_due_flashcards",collection:h,userId:e})}async getFlashcardsByCategory(e,t,s={}){return l(async()=>{const a=await E.findMany({userId:e,category:t},{limit:s.limit||50,skip:s.skip||0,sort:{createdAt:-1}});if(!a.success)throw new p(a.error||"Failed to retrieve flashcards by category","GET_FLASHCARDS_BY_CATEGORY_FAILED","get_flashcards_by_category",h);return a},{operation:"get_flashcards_by_category",collection:h,userId:e})}async getAllFlashcards(e,t={}){return l(async()=>{const s=await E.findMany({userId:e},{limit:t.limit||1e3,skip:t.skip||0,sort:{createdAt:-1}});if(!s.success)throw new p(s.error||"Failed to retrieve all flashcards","GET_ALL_FLASHCARDS_FAILED","get_all_flashcards",h);return s},{operation:"get_all_flashcards",collection:h,userId:e})}async searchFlashcards(e,t,s={}){return l(async()=>{const a={userId:e,$or:[{front:new RegExp(t,"i")},{back:new RegExp(t,"i")},{exampleFront:new RegExp(t,"i")},{exampleBack:new RegExp(t,"i")},{tags:{$in:[new RegExp(t,"i")]}}]};s.category&&(a.category=s.category);const r=await E.findMany(a,{limit:s.limit||20,sort:{createdAt:-1}});if(!r.success)throw new p(r.error||"Failed to search flashcards","SEARCH_FLASHCARDS_FAILED","search_flashcards",h);return r},{operation:"search_flashcards",collection:h,userId:e})}async suspendFlashcard(e,t,s,a){return l(async()=>{const r={"sm2.isSuspended":t,"sm2.suspensionReason":t?s:null};if(t)r["sm2.nextReviewDate"]=new Date(Date.now()+365*24*60*60*1e3);else{const n=await this.getFlashcardById(e,a);n.success&&n.data&&(r["sm2.nextReviewDate"]=Y(n.data.sm2.interval,n.data.sm2.easeFactor,3))}const i=await E.updateOne({cardId:e,userId:a},{$set:r});if(!i.success)throw new p(i.error||`Failed to ${t?"suspend":"unsuspend"} flashcard`,"SUSPEND_FLASHCARD_FAILED","suspend_flashcard",h);return this.getFlashcardById(e,a)},{operation:"suspend_flashcard",collection:h,userId:a})}async deleteFlashcard(e,t){return l(async()=>{const s=await E.deleteOne({cardId:e,userId:t});if(!s.success)throw new p(s.error||"Failed to delete flashcard","DELETE_FLASHCARD_FAILED","delete_flashcard",h);return s},{operation:"delete_flashcard",collection:h,userId:t})}async getFlashcardStats(e,t){return l(async()=>{const s={userId:e};t&&(s.cardId=t);const a=await E.findMany(s);if(!a.success)throw new p(a.error||"Failed to get flashcard statistics","GET_FLASHCARD_STATS_FAILED","get_flashcard_stats",h);const i=(a.data||[]).reduce((c,u)=>{c.totalCards+=1;const m=u.sm2?.repetitions??0;return m===0?c.newCards+=1:m<5?c.learningCards+=1:c.matureCards+=1,u.sm2?.isSuspended&&(c.suspendedCards+=1),typeof u.sm2?.easeFactor=="number"&&(c.totalEaseFactor+=u.sm2.easeFactor),typeof u.sm2?.interval=="number"&&(c.totalInterval+=u.sm2.interval),typeof u.sm2?.totalReviews=="number"&&(c.totalReviews+=u.sm2.totalReviews),c},{totalCards:0,newCards:0,learningCards:0,matureCards:0,suspendedCards:0,totalEaseFactor:0,totalInterval:0,totalReviews:0}),n=i.totalCards>0?i.totalEaseFactor/i.totalCards:0,o=i.totalCards>0?i.totalInterval/i.totalCards:0;return{success:!0,data:{totalCards:i.totalCards,newCards:i.newCards,learningCards:i.learningCards,matureCards:i.matureCards,suspendedCards:i.suspendedCards,averageEaseFactor:n,averageInterval:o,totalReviews:i.totalReviews},operationTime:a.operationTime}},{operation:"get_flashcard_stats",collection:h,userId:e})}sanitizeCardData(e){const t={...e};return t.front&&(t.front=A(String(t.front))),t.back&&(t.back=A(String(t.back))),t.exampleFront&&(t.exampleFront=A(String(t.exampleFront))),t.exampleBack&&(t.exampleBack=A(String(t.exampleBack))),t.category&&(t.category=A(String(t.category))),t.tags&&Array.isArray(t.tags)&&(t.tags=t.tags.map(s=>A(String(s)))),t}async checkForDuplicateCard(e,t){const s=await E.findOne({userId:e,cardId:t});if(s.success&&s.data)throw new $(`Flashcard with ID ${t} already exists for this user`,"create_flashcard",h,"cardId",t)}calculateNewSM2Params(e,t){const s=e.easeFactor,a=e.repetitions,r=e.interval,i=Math.max(1.3,s+(.1-(5-t)*(.08+(5-t)*.02)));let n=r,o=a;t>=3?(a===0?n=1:a===1?n=6:n=Math.round(r*i),o=a+1):(o=0,n=1);const c=Y(n,i,t),u=t>=3?(e.correctStreak??0)+1:0,m=t>=3?0:(e.incorrectStreak??0)+1;return{...e,easeFactor:i,interval:n,repetitions:o,nextReviewDate:c,correctStreak:u,incorrectStreak:m}}updateCardStatistics(e,t,s){const a=e.timesCorrect,r=e.timesIncorrect,i=e.averageResponseTime,n=t>=3?a+1:a,o=t>=3?r:r+1,c=n+o;let u=i;if(c>0){const w=a+r;u=(i*w+s)/c}const m=c>0?n/c:0;let y=e.lastDifficulty;return m>=.8?y="easy":m>=.6?y="medium":y="hard",{timesCorrect:n,timesIncorrect:o,averageResponseTime:u,lastDifficulty:y}}}const _=new De,S="study_sessions",v=L(S);class Re{async createStudySession(e,t){return l(async()=>{U(e.userId,t,S),z(e,["sessionId","userId","startTime","cardsStudied"],S);const s=this.sanitizeSessionData(e),a=O(s,ee);if(!a.isValid)throw new T(`Study session validation failed: ${a.errors.join(", ")}`,"create_study_session",S);await this.checkForDuplicateSession(s.userId,s.sessionId);const r=await v.create(s);if(!r.success)throw new p(r.error||"Failed to create study session","CREATE_STUDY_SESSION_FAILED","create_study_session",S);return r},{operation:"create_study_session",collection:S,userId:t})}async getStudySessionById(e,t){return l(async()=>{const s=await v.findOne({sessionId:e,userId:t});if(!s.success)throw new p(s.error||"Failed to retrieve study session","GET_STUDY_SESSION_FAILED","get_study_session_by_id",S);if(!s.data)throw new k(`Study session with ID ${e} not found`,"get_study_session_by_id",S,e);return s},{operation:"get_study_session_by_id",collection:S,userId:t})}async endStudySession(e,t,s){return l(async()=>{const a=await this.getStudySessionById(e,s);if(!a.success||!a.data)throw new k(`Study session with ID ${e} not found`,"end_study_session",S,e);const r=a.data,i=Math.floor((t.endTime.getTime()-r.startTime.getTime())/1e3),n=t.performance||this.calculateSessionPerformance(t.finalCardsStudied),o={endTime:t.endTime,duration:i,cardsStudied:t.finalCardsStudied,totalCards:t.finalCardsStudied.length,performance:n},c=await v.updateOne({sessionId:e,userId:s},{$set:o});if(!c.success)throw new p(c.error||"Failed to end study session","END_STUDY_SESSION_FAILED","end_study_session",S);return this.getStudySessionById(e,s)},{operation:"end_study_session",collection:S,userId:s})}async updateSessionProgress(e,t,s){return l(async()=>{const a=t.currentPerformance||this.calculateSessionPerformance(t.cardsStudied),r={cardsStudied:t.cardsStudied,totalCards:t.cardsStudied.length,performance:a},i=await v.updateOne({sessionId:e,userId:s},{$set:r});if(!i.success)throw new p(i.error||"Failed to update session progress","UPDATE_SESSION_PROGRESS_FAILED","update_session_progress",S);return this.getStudySessionById(e,s)},{operation:"update_session_progress",collection:S,userId:s})}async getUserStudySessions(e,t={}){return l(async()=>{const s={userId:e};t.dateRange&&(s.startTime={$gte:t.dateRange.start,$lte:t.dateRange.end}),t.sessionType&&(s.sessionType=t.sessionType);const a=t.sortBy||"startTime",r=t.sortOrder||-1,i=await v.findMany(s,{limit:t.limit||50,skip:t.skip||0,sort:{[a]:r}});if(!i.success)throw new p(i.error||"Failed to retrieve study sessions","GET_USER_STUDY_SESSIONS_FAILED","get_user_study_sessions",S);return i},{operation:"get_user_study_sessions",collection:S,userId:e})}async getStudySessionStats(e,t){return l(async()=>{const s={userId:e};t&&(s.startTime={$gte:t.start,$lte:t.end});const a=await v.findMany(s);if(!a.success)throw new p(a.error||"Failed to get study session statistics","GET_STUDY_SESSION_STATS_FAILED","get_study_session_stats",S);const i=(a.data||[]).reduce((u,m)=>{u.totalSessions+=1,m.endTime&&(u.completedSessions+=1);const y=typeof m.duration=="number"?Number(m.duration):m.endTime?Math.floor((m.endTime.getTime()-m.startTime.getTime())/1e3):0;return u.totalDuration+=y,u.totalCardsStudied+=m.totalCards??m.cardsStudied?.length??0,u.totalPerformance+=m.performance?.overallScore??0,u.sessionsByType.push(m.sessionType),u},{totalSessions:0,completedSessions:0,totalDuration:0,totalCardsStudied:0,totalPerformance:0,sessionsByType:[]}),n=i.totalSessions>0?i.totalDuration/i.totalSessions:0,o=i.totalSessions>0?i.totalCardsStudied/i.totalSessions:0,c=i.totalSessions>0?i.totalPerformance/i.totalSessions:0;return{success:!0,data:{totalSessions:i.totalSessions,completedSessions:i.completedSessions,totalDuration:i.totalDuration,averageDuration:n,totalCardsStudied:i.totalCardsStudied,averageCardsPerSession:o,averagePerformance:c,sessionsByType:i.sessionsByType},operationTime:a.operationTime}},{operation:"get_study_session_stats",collection:S,userId:e})}async deleteStudySession(e,t){return l(async()=>{const s=await v.deleteOne({sessionId:e,userId:t});if(!s.success)throw new p(s.error||"Failed to delete study session","DELETE_STUDY_SESSION_FAILED","delete_study_session",S);return s},{operation:"delete_study_session",collection:S,userId:t})}async getRecentSessions(e,t=10){return l(async()=>{const s=await v.findMany({userId:e},{limit:t,sort:{startTime:-1}});if(!s.success)throw new p(s.error||"Failed to retrieve recent sessions","GET_RECENT_SESSIONS_FAILED","get_recent_sessions",S);return s},{operation:"get_recent_sessions",collection:S,userId:e})}async getStudyStreak(e){return l(async()=>{const t=await v.findMany({userId:e,endTime:{$ne:null}},{sort:{startTime:-1}});if(!t.success)throw new p(t.error||"Failed to calculate study streak","GET_STUDY_STREAK_FAILED","get_study_streak",S);const s=t.data||[];return{success:!0,data:this.calculateStreak(s),operationTime:t.operationTime}},{operation:"get_study_streak",collection:S,userId:e})}sanitizeSessionData(e){const t={...e};return t.sessionType&&(t.sessionType=A(t.sessionType)),t}async checkForDuplicateSession(e,t){const s=await v.findOne({userId:e,sessionId:t});if(s.success&&s.data)throw new $(`Study session with ID ${t} already exists for this user`,"create_study_session",S,"sessionId",t)}calculateSessionPerformance(e){if(!e||e.length===0)return{overallScore:0,improvement:0,focusAreas:[]};const t=e.length,a=e.filter(y=>y.wasCorrect).length/t*100,r=e.reduce((y,w)=>y+(w.responseTime||0),0)/t,i=e.map(y=>y.responseTime||0),n=i.reduce((y,w)=>y+w,0)/i.length,o=i.reduce((y,w)=>y+Math.pow(w-n,2),0)/i.length,c=Math.sqrt(o),u=[];return a<70&&u.push("retention"),r>1e4&&u.push("speed"),c>5e3&&u.push("consistency"),{overallScore:Math.round(a*.7+(r<5e3?100:Math.max(0,100-(r-5e3)/100))*.2+(c<3e3?100:Math.max(0,100-(c-3e3)/100))*.1),improvement:0,focusAreas:u}}calculateStreak(e){if(e.length===0)return{currentStreak:0,longestStreak:0};const t=e.sort((u,m)=>m.startTime.getTime()-u.startTime.getTime()),s=new Date;s.setHours(0,0,0,0);let a=0,r=0,i=0,n=null;for(const u of t){const m=new Date(u.startTime);if(m.setHours(0,0,0,0),!n)i=1,n=m;else{const y=Math.floor((n.getTime()-m.getTime())/864e5);if(y===1)i++;else{if(y===0)continue;r=Math.max(r,i),i=1}n=m}}const o=new Date(t[0].startTime);return o.setHours(0,0,0,0),Math.floor((s.getTime()-o.getTime())/(1e3*60*60*24))<=1&&(a=i),r=Math.max(r,i),{currentStreak:a,longestStreak:r,lastStudyDate:t[0]?.startTime}}}const C=new Re,g="study_statistics",I=L(g);class ve{async createStudyStatistics(e,t){return l(async()=>{U(e.userId,t,g),z(e,["statsId","userId","date","dailyStats"],g);const s=this.sanitizeStatsData(e),a=O(s,X);if(!a.isValid)throw new T(`Study statistics validation failed: ${a.errors.join(", ")}`,"create_study_statistics",g);const r=this.ensureString(s.userId,"userId","create_study_statistics"),i=this.ensureString(s.statsId,"statsId","create_study_statistics");s.userId=r,s.statsId=i,await this.checkForDuplicateStats(r,i);const n=await I.create(s);if(!n.success)throw new p(n.error||"Failed to create study statistics","CREATE_STUDY_STATISTICS_FAILED","create_study_statistics",g);return n},{operation:"create_study_statistics",collection:g,userId:t})}async getStudyStatisticsById(e,t){return l(async()=>{const s=await I.findOne({statsId:e,userId:t});if(!s.success)throw new p(s.error||"Failed to retrieve study statistics","GET_STUDY_STATISTICS_FAILED","get_study_statistics_by_id",g);if(!s.data)throw new k(`Study statistics with ID ${e} not found`,"get_study_statistics_by_id",g,e);return s},{operation:"get_study_statistics_by_id",collection:g,userId:t})}async getStudyStatisticsByDate(e,t,s="daily"){return l(async()=>{const a=await I.findOne({userId:e,date:this.normalizeDate(t,s),period:s});if(!a.success)throw new p(a.error||"Failed to retrieve study statistics for date","GET_STUDY_STATISTICS_BY_DATE_FAILED","get_study_statistics_by_date",g);return a},{operation:"get_study_statistics_by_date",collection:g,userId:e})}async updateStudyStatistics(e,t,s){return l(async()=>{const a=await this.getStudyStatisticsById(e,s);if(!a.success||!a.data)throw new k(`Study statistics with ID ${e} not found`,"update_study_statistics",g,e);const r=this.sanitizeStatsData(t),i={...a.data,...r},n=O(i,X);if(!n.isValid)throw new T(`Study statistics validation failed: ${n.errors.join(", ")}`,"update_study_statistics",g);const o=await I.updateOne({statsId:e,userId:s},{$set:r});if(!o.success)throw new p(o.error||"Failed to update study statistics","UPDATE_STUDY_STATISTICS_FAILED","update_study_statistics",g);return this.getStudyStatisticsById(e,s)},{operation:"update_study_statistics",collection:g,userId:s})}async upsertDailyStatistics(e,t,s){return l(async()=>{const a=this.normalizeDate(t,"daily"),r=this.generateStatsId(e,a,"daily"),i=await I.findOne({userId:e,date:a,period:"daily"});if(i.success&&i.data)return this.updateStudyStatistics(r,{dailyStats:s},e);{const n={statsId:r,userId:e,date:a,period:"daily",dailyStats:s};return this.createStudyStatistics(n,e)}},{operation:"upsert_daily_statistics",collection:g,userId:e})}async getStudyStatisticsRange(e,t,s,a="daily",r={}){return l(async()=>{const i=await I.findMany({userId:e,period:a,date:{$gte:this.normalizeDate(t,a),$lte:this.normalizeDate(s,a)}},{limit:r.limit||100,skip:r.skip||0,sort:{date:1}});if(!i.success)throw new p(i.error||"Failed to retrieve study statistics range","GET_STUDY_STATISTICS_RANGE_FAILED","get_study_statistics_range",g);return i},{operation:"get_study_statistics_range",collection:g,userId:e})}async calculateWeeklyStatistics(e,t){return l(async()=>{const s=new Date(t);s.setDate(t.getDate()+6);const a=await this.getStudyStatisticsRange(e,t,s,"daily");if(!a.success||!a.data)throw new p("Failed to retrieve daily statistics for weekly calculation","CALCULATE_WEEKLY_STATS_FAILED","calculate_weekly_statistics",g);const r=this.aggregateStats(a.data),i=this.normalizeDate(t,"weekly"),o={statsId:this.generateStatsId(e,i,"weekly"),userId:e,date:i,period:"weekly",dailyStats:{cardsStudied:r.totalCards,studyTime:r.totalTime,correctAnswers:r.totalCorrect,incorrectAnswers:r.totalIncorrect,averageRecallRate:r.averageRate},weeklyStats:r};return this.upsertWeeklyStatistics(o,e)},{operation:"calculate_weekly_statistics",collection:g,userId:e})}async calculateMonthlyStatistics(e,t){return l(async()=>{const s=new Date(t.getFullYear(),t.getMonth()+1,0),a=await this.getStudyStatisticsRange(e,t,s,"weekly");if(!a.success||!a.data)throw new p("Failed to retrieve weekly statistics for monthly calculation","CALCULATE_MONTHLY_STATS_FAILED","calculate_monthly_statistics",g);const r=this.aggregateStats(a.data),i=this.normalizeDate(t,"monthly"),o={statsId:this.generateStatsId(e,i,"monthly"),userId:e,date:i,period:"monthly",dailyStats:{cardsStudied:r.totalCards,studyTime:r.totalTime,correctAnswers:r.totalCorrect,incorrectAnswers:r.totalIncorrect,averageRecallRate:r.averageRate},monthlyStats:r};return this.upsertMonthlyStatistics(o,e)},{operation:"calculate_monthly_statistics",collection:g,userId:e})}async getStudyStatisticsSummary(e,t=30){return l(async()=>{const s=new Date,a=new Date;a.setDate(s.getDate()-t);const r=await this.getStudyStatisticsRange(e,a,s,"daily");if(!r.success||!r.data)return{success:!0,data:{totalDays:0,totalCardsStudied:0,totalStudyTime:0,averageDailyCards:0,averageDailyTime:0,averageRecallRate:0,studyDays:0,consistency:0},operationTime:0};const i=r.data;return{success:!0,data:this.calculateSummary(i,t),operationTime:r.operationTime}},{operation:"get_study_statistics_summary",collection:g,userId:e})}async deleteStudyStatistics(e,t){return l(async()=>{const s=await I.deleteOne({statsId:e,userId:t});if(!s.success)throw new p(s.error||"Failed to delete study statistics","DELETE_STUDY_STATISTICS_FAILED","delete_study_statistics",g);return s},{operation:"delete_study_statistics",collection:g,userId:t})}sanitizeStatsData(e){return{...e}}async checkForDuplicateStats(e,t){const s=await I.findOne({userId:e,statsId:t});if(s.success&&s.data)throw new $(`Study statistics with ID ${t} already exists for this user`,"create_study_statistics",g,"statsId",t)}ensureString(e,t,s){if(typeof e!="string")throw new T(`${t} must be a string`,s,g,t,e);return e}normalizeDate(e,t){const s=new Date(e);switch(t){case"daily":s.setHours(0,0,0,0);break;case"weekly":{const a=s.getDay();s.setDate(s.getDate()-a),s.setHours(0,0,0,0);break}case"monthly":s.setDate(1),s.setHours(0,0,0,0);break}return s}generateStatsId(e,t,s){const a=t.toISOString().split("T")[0];return`${e}_${s}_${a}`}aggregateStats(e){if(e.length===0)return{totalCards:0,totalTime:0,totalCorrect:0,totalIncorrect:0,averageRate:0,improvement:0};const t=e.reduce((s,a)=>{const r=a.dailyStats;return{totalCards:s.totalCards+(r.cardsStudied||0),totalTime:s.totalTime+(r.studyTime||0),totalCorrect:s.totalCorrect+(r.correctAnswers||0),totalIncorrect:s.totalIncorrect+(r.incorrectAnswers||0),totalRate:s.totalRate+(r.averageRecallRate||0)}},{totalCards:0,totalTime:0,totalCorrect:0,totalIncorrect:0,totalRate:0});return{totalCards:t.totalCards,totalTime:t.totalTime,averageRate:e.length>0?t.totalRate/e.length:0,improvement:this.calculateImprovement(e),totalCorrect:t.totalCorrect,totalIncorrect:t.totalIncorrect}}calculateImprovement(e){if(e.length<2)return 0;const t=e.sort((n,o)=>n.date.getTime()-o.date.getTime()),s=t.slice(0,Math.floor(t.length/2)),a=t.slice(Math.floor(t.length/2)),r=s.reduce((n,o)=>n+(o.dailyStats.averageRecallRate||0),0)/s.length;return a.reduce((n,o)=>n+(o.dailyStats.averageRecallRate||0),0)/a.length-r}calculateSummary(e,t){const s=e.reduce((n,o)=>{const c=o.dailyStats;return{totalCards:n.totalCards+(c.cardsStudied||0),totalTime:n.totalTime+(c.studyTime||0),totalCorrect:n.totalCorrect+(c.correctAnswers||0),totalIncorrect:n.totalIncorrect+(c.incorrectAnswers||0),totalRate:n.totalRate+(c.averageRecallRate||0)}},{totalCards:0,totalTime:0,totalCorrect:0,totalIncorrect:0,totalRate:0}),a=e.length,r=a>0?s.totalRate/a:0,i=a>0?a/t*100:0;return{totalDays:t,totalCardsStudied:s.totalCards,totalStudyTime:s.totalTime,averageDailyCards:a>0?s.totalCards/a:0,averageDailyTime:a>0?s.totalTime/a:0,averageRecallRate:r,studyDays:a,consistency:i}}async upsertWeeklyStatistics(e,t){const s=this.ensureString(e.userId,"userId","upsert_weekly_statistics"),a=this.ensureString(e.statsId,"statsId","upsert_weekly_statistics"),r={...e,userId:s,statsId:a},i=await I.findOne({userId:s,date:e.date,period:"weekly"});return i.success&&i.data?this.updateStudyStatistics(a,r,t):this.createStudyStatistics(r,t)}async upsertMonthlyStatistics(e,t){const s=this.ensureString(e.userId,"userId","upsert_monthly_statistics"),a=this.ensureString(e.statsId,"statsId","upsert_monthly_statistics"),r={...e,userId:s,statsId:a},i=await I.findOne({userId:s,date:e.date,period:"monthly"});return i.success&&i.data?this.updateStudyStatistics(a,r,t):this.createStudyStatistics(r,t)}}const R=new ve;class Ie{async bulkImportFlashcards(e,t,s={}){return l(async()=>{const{skipDuplicates:a=!0,updateExisting:r=!1,batchSize:i=100}=s;if(!t.length)return{success:!0,data:{success:!0,insertedCount:0,updatedCount:0,deletedCount:0,errors:[],operationTime:0},operationTime:0};const n={inserted:0,updated:0,skipped:0,errors:[]};for(let c=0;c<t.length;c+=i){const u=t.slice(c,c+i),m=await this.processFlashcardBatch(e,u,{skipDuplicates:a,updateExisting:r});n.inserted+=m.inserted,n.updated+=m.updated,n.skipped+=m.skipped,n.errors.push(...m.errors.map(y=>({index:y.index+c,error:y.error})))}return{success:!0,data:{success:n.errors.length===0,insertedCount:n.inserted,updatedCount:n.updated,deletedCount:0,errors:n.errors.map(c=>c.error.message),operationTime:Date.now()},operationTime:Date.now()}},{operation:"bulk_import_flashcards",userId:e})}async bulkUpdateSM2Parameters(e,t){return l(async()=>{const s={processed:0,errors:[]};for(let r=0;r<t.length;r++){const i=t[r];try{const n=await _.processReviewResponse(i.cardId,i.quality,i.responseTime,e);n.success?s.processed++:s.errors.push({index:r,error:new Error(n.error||"Unknown error")})}catch(n){s.errors.push({index:r,error:n})}}return{success:!0,data:{success:s.errors.length===0,insertedCount:0,updatedCount:s.processed,deletedCount:0,errors:s.errors.map(r=>r.error.message),operationTime:Date.now()},operationTime:Date.now()}},{operation:"bulk_update_sm2_parameters",userId:e})}async bulkSuspendFlashcards(e,t,s,a){return l(async()=>{const r={processed:0,errors:[]};for(let n=0;n<t.length;n++){const o=t[n];try{const c=await _.suspendFlashcard(o,s,a,e);c.success?r.processed++:r.errors.push({index:n,error:new Error(c.error||"Unknown error")})}catch(c){r.errors.push({index:n,error:c})}}return{success:!0,data:{success:r.errors.length===0,insertedCount:0,updatedCount:r.processed,deletedCount:0,errors:r.errors.map(n=>n.error.message),operationTime:Date.now()},operationTime:Date.now()}},{operation:"bulk_suspend_flashcards",userId:e})}async bulkDeleteFlashcards(e,t){return l(async()=>{const s=L("flashcards"),a=t.map(i=>({deleteOne:{filter:{cardId:i,userId:e}}})),r=await s.bulkWrite(a);if(!r.success)throw new he(r.error||"Failed to bulk delete flashcards","bulk_delete_flashcards","flashcards",0,0,(r.data?.errors||[]).map((i,n)=>({index:n,error:new Error(i)})));return r},{operation:"bulk_delete_flashcards",userId:e})}async bulkCreateStudySessions(e,t){return l(async()=>{const s={inserted:0,errors:[]};for(let r=0;r<t.length;r++){const i=t[r];try{const n=await C.createStudySession(i,e);n.success?s.inserted++:s.errors.push({index:r,error:new Error(n.error||"Unknown error")})}catch(n){s.errors.push({index:r,error:n})}}return{success:!0,data:{success:s.errors.length===0,insertedCount:s.inserted,updatedCount:0,deletedCount:0,errors:s.errors.map(r=>r.error.message),operationTime:Date.now()},operationTime:Date.now()}},{operation:"bulk_create_study_sessions",userId:e})}async bulkUpdateUserStatistics(e,t){return l(async()=>M.updateUserStatistics(e,t),{operation:"bulk_update_user_statistics",userId:e})}async bulkExportUserData(e,t={}){return l(async()=>{const s={userId:e,exportedAt:new Date,data:{}},a=await M.getUserById(e);if(a.success&&a.data&&(s.data.user=a.data),t.includeFlashcards){const r=await _.getDueFlashcards(e,{limit:1e4});r.success&&r.data&&(s.data.flashcards=r.data)}if(t.includeSessions){const r=await C.getUserStudySessions(e,{limit:1e3,dateRange:t.dateRange});r.success&&r.data&&(s.data.studySessions=r.data)}if(t.includeStatistics){const r=await R.getStudyStatisticsRange(e,t.dateRange?.start||new Date(Date.now()-2592e6),t.dateRange?.end||new Date,"daily",{limit:1e3});r.success&&r.data&&(s.data.studyStatistics=r.data)}return{success:!0,data:s,operationTime:Date.now()}},{operation:"bulk_export_user_data",userId:e})}async bulkImportUserData(e,t,s={}){return l(async()=>{const a={flashcards:{inserted:0,updated:0,errors:0},studySessions:{inserted:0,updated:0,errors:0},studyStatistics:{inserted:0,updated:0,errors:0}};if(t.flashcards&&t.flashcards.length>0){const r=await this.bulkImportFlashcards(e,t.flashcards,{skipDuplicates:s.skipExisting,updateExisting:s.updateExisting});r.success&&r.data&&(a.flashcards.inserted=r.data.insertedCount,a.flashcards.updated=r.data.updatedCount,a.flashcards.errors=r.data.errors.length)}if(t.studySessions&&t.studySessions.length>0){const r=await this.bulkCreateStudySessions(e,t.studySessions);r.success&&r.data&&(a.studySessions.inserted=r.data.insertedCount,a.studySessions.updated=r.data.updatedCount,a.studySessions.errors=r.data.errors.length)}if(t.studyStatistics&&t.studyStatistics.length>0)for(const r of t.studyStatistics)try{await R.createStudyStatistics(r,e),a.studyStatistics.inserted++}catch{a.studyStatistics.errors++}return{success:!0,data:{success:!0,results:a,totalProcessed:a.flashcards.inserted+a.flashcards.updated+a.studySessions.inserted+a.studySessions.updated+a.studyStatistics.inserted+a.studyStatistics.updated,totalErrors:a.flashcards.errors+a.studySessions.errors+a.studyStatistics.errors},operationTime:Date.now()}},{operation:"bulk_import_user_data",userId:e})}async bulkCleanupOldData(e,t={}){return l(async()=>{const{olderThanDays:s=365,cleanupSessions:a=!0,cleanupStatistics:r=!1}=t,i=new Date(Date.now()-s*24*60*60*1e3),n={deleted:0,errors:[]};if(a)try{const u=await L("study_sessions").deleteMany({userId:e,startTime:{$lt:i}});u.success&&u.data&&(n.deleted+=u.data.deletedCount)}catch(c){n.errors.push(`Failed to cleanup study sessions: ${c}`)}if(r)try{const u=await L("study_statistics").deleteMany({userId:e,date:{$lt:i}});u.success&&u.data&&(n.deleted+=u.data.deletedCount)}catch(c){n.errors.push(`Failed to cleanup statistics: ${c}`)}return{success:!0,data:{success:n.errors.length===0,insertedCount:0,updatedCount:0,deletedCount:n.deleted,errors:n.errors,operationTime:Date.now()},operationTime:Date.now()}},{operation:"bulk_cleanup_old_data",userId:e})}async processFlashcardBatch(e,t,s){const a={inserted:0,updated:0,skipped:0,errors:[]};for(let r=0;r<t.length;r++){const i=t[r];try{if(typeof i.cardId!="string")throw new T("Flashcard cardId must be a non-empty string","bulk_import_flashcards","flashcards","cardId",i.cardId);const n=i.cardId.trim();if(n.length===0)throw new T("Flashcard cardId must be a non-empty string","bulk_import_flashcards","flashcards","cardId",i.cardId);i.cardId=n;const o=O(i,P);if(!o.isValid)throw new T(`Flashcard validation failed: ${o.errors.join(", ")}`,"bulk_import_flashcards","flashcards");const c=await _.getFlashcardById(n,e);if(c.success&&c.data)if(s.skipDuplicates){a.skipped++;continue}else if(s.updateExisting){const u=await _.updateFlashcard(n,i,e);if(u.success)a.updated++;else throw new Error(u.error||"Failed to update flashcard")}else throw new Error(`Flashcard with ID ${i.cardId} already exists`);else{const u=await _.createFlashcard(i,e);if(u.success)a.inserted++;else throw new Error(u.error||"Failed to create flashcard")}}catch(n){a.errors.push({index:r,error:n})}}return a}}const B=new Ie;class Ae{constructor(){this.activeSyncSessions=new Map}async startSyncSession(e){return l(async()=>{const t=`sync_${e}_${Date.now()}`,s={sessionId:t,userId:e,startTime:new Date,status:"in_progress",totalItems:0,syncedItems:0,conflicts:[],errors:[]};return this.activeSyncSessions.set(t,s),{success:!0,data:s,operationTime:Date.now()}},{operation:"start_sync_session",userId:e})}async syncFromLocal(e,t,s={}){return l(async()=>{const a=await this.startSyncSession(e);if(!a.success||!a.data)throw new p("Failed to start sync session","SYNC_FAILED","sync_from_local");const r=a.data,{resolveConflicts:i="merge",skipExisting:n=!1,batchSize:o=50}=s;try{return r.totalItems=(t.flashcards?.length||0)+(t.studySessions?.length||0)+(t.studyStatistics?.length||0),t.flashcards&&t.flashcards.length>0&&await this.syncFlashcards(r,t.flashcards,{resolveConflicts:i,skipExisting:n,batchSize:o}),t.studySessions&&t.studySessions.length>0&&await this.syncStudySessions(r,t.studySessions,{resolveConflicts:i,skipExisting:n,batchSize:o}),t.studyStatistics&&t.studyStatistics.length>0&&await this.syncStudyStatistics(r,t.studyStatistics,{resolveConflicts:i,skipExisting:n,batchSize:o}),r.endTime=new Date,r.status=(r.conflicts.length>0,"completed"),this.activeSyncSessions.set(r.sessionId,r),{success:!0,data:r,operationTime:Date.now()}}catch(c){throw r.status="failed",r.errors.push(c instanceof Error?c.message:"Unknown sync error"),r.endTime=new Date,c}},{operation:"sync_from_local",userId:e})}async syncToLocal(e,t={}){return l(async()=>{const{since:s,includeFlashcards:a=!0,includeSessions:r=!0,includeStatistics:i=!0,limit:n=1e3}=t,o={userId:e,syncedAt:new Date,data:{}};if(a){const c=await _.getDueFlashcards(e,{limit:n,includeSuspended:!0});c.success&&c.data&&(o.data.flashcards=c.data)}if(r){const c=await C.getUserStudySessions(e,{limit:n,dateRange:s?{start:s,end:new Date}:void 0});c.success&&c.data&&(o.data.studySessions=c.data)}if(i){const c=await R.getStudyStatisticsRange(e,s||new Date(Date.now()-2592e6),new Date,"daily",{limit:n});c.success&&c.data&&(o.data.studyStatistics=c.data)}return{success:!0,data:o,operationTime:Date.now()}},{operation:"sync_to_local",userId:e})}async resolveConflicts(e,t){return l(async()=>{const s=this.activeSyncSessions.get(e);if(!s)throw new T("Sync session not found","resolve_conflicts");for(const a of t){const r=s.conflicts[a.conflictIndex];r&&(r.resolved=!0,r.resolution=a.resolution,await this.applyConflictResolution(r,a))}return{success:!0,data:s,operationTime:Date.now()}},{operation:"resolve_conflicts"})}async getSyncStatus(e){return l(async()=>{const t=await M.getUserById(e),s=t.success&&t.data?.updatedAt?t.data.updatedAt:void 0,a=await this.getPendingSyncCounts(e,s);return{success:!0,data:{userId:e,lastSyncTimestamp:s,pendingItems:a,activeSyncSessions:Array.from(this.activeSyncSessions.values()).filter(r=>r.userId===e)},operationTime:Date.now()}},{operation:"get_sync_status",userId:e})}async migrateUserData(e,t,s={}){return l(async()=>{const{validateData:a=!0,transformData:r=!0,batchSize:i=100}=s,n={success:!0,migratedItems:{flashcards:0,studySessions:0,studyStatistics:0},errors:[],skippedItems:0};let o=t;if(r&&(o=await this.transformMigrationData(t,e)),a){const c=await this.validateMigrationData(o);if(!c.isValid&&(n.errors.push(...c.errors),c.errors.length>0))return n.success=!1,{success:!1,data:n,operationTime:Date.now()}}if(o.flashcards&&o.flashcards.length>0){const c=await B.bulkImportFlashcards(e,o.flashcards,{skipDuplicates:!0,batchSize:i});c.success&&c.data&&(n.migratedItems.flashcards=c.data.insertedCount,c.data.errors.length>0&&n.errors.push(...c.data.errors))}if(o.studySessions&&o.studySessions.length>0){const c=await B.bulkCreateStudySessions(e,o.studySessions);c.success&&c.data&&(n.migratedItems.studySessions=c.data.insertedCount,c.data.errors.length>0&&n.errors.push(...c.data.errors))}if(o.studyStatistics&&o.studyStatistics.length>0)for(const c of o.studyStatistics)try{await R.createStudyStatistics(c,e),n.migratedItems.studyStatistics++}catch(u){n.errors.push(`Failed to migrate study statistics: ${u}`)}return{success:n.success,data:n,operationTime:Date.now()}},{operation:"migrate_user_data",userId:e})}async cleanupSyncSessions(e=24){return l(async()=>{const t=new Date(Date.now()-e*60*60*1e3);let s=0;for(const[a,r]of this.activeSyncSessions.entries())r.startTime<t&&(this.activeSyncSessions.delete(a),s++);return{success:!0,data:s,operationTime:Date.now()}},{operation:"cleanup_sync_sessions"})}async syncFlashcards(e,t,s){for(let a=0;a<t.length;a+=s.batchSize){const r=t.slice(a,a+s.batchSize);for(const i of r)try{const n=await _.getFlashcardById(i.cardId,e.userId);if(n.success&&n.data){const o=await this.createConflict(e,"flashcards",i.cardId,i,n.data,"update");await this.resolveConflictAutomatically(o,s.resolveConflicts)}else await _.createFlashcard(i,e.userId);e.syncedItems++}catch(n){e.errors.push(`Failed to sync flashcard ${i.cardId}: ${n}`)}}}async syncStudySessions(e,t,s){for(let a=0;a<t.length;a+=s.batchSize){const r=t.slice(a,a+s.batchSize);for(const i of r)try{const n=await C.getStudySessionById(i.sessionId,e.userId);if(n.success&&n.data){const o=await this.createConflict(e,"study_sessions",i.sessionId,i,n.data,"update");await this.resolveConflictAutomatically(o,s.resolveConflicts)}else await C.createStudySession(i,e.userId);e.syncedItems++}catch(n){e.errors.push(`Failed to sync study session ${i.sessionId}: ${n}`)}}}async syncStudyStatistics(e,t,s){for(let a=0;a<t.length;a+=s.batchSize){const r=t.slice(a,a+s.batchSize);for(const i of r)try{const n=await R.getStudyStatisticsById(i.statsId,e.userId);if(n.success&&n.data){const o=await this.createConflict(e,"study_statistics",i.statsId,i,n.data,"update");await this.resolveConflictAutomatically(o,s.resolveConflicts)}else await R.createStudyStatistics(i,e.userId);e.syncedItems++}catch(n){e.errors.push(`Failed to sync study statistics ${i.statsId}: ${n}`)}}}async createConflict(e,t,s,a,r,i){const n={collection:t,documentId:s,localVersion:a,remoteVersion:r,conflictType:i,resolved:!1,timestamp:new Date};return e.conflicts.push(n),n}async resolveConflictAutomatically(e,t){switch(t){case"local":e.resolution="local",e.resolved=!0,await this.applyLocalVersion(e);break;case"remote":e.resolution="remote",e.resolved=!0;break;case"merge":e.resolution="merge",e.resolved=!0,await this.mergeVersions(e);break}}async applyConflictResolution(e,t){switch(t.resolution){case"local":await this.applyLocalVersion(e);break;case"remote":break;case"merge":t.mergedData?await this.applyMergedVersion(e,t.mergedData):await this.mergeVersions(e);break}}async applyLocalVersion(e){switch(e.collection){case"flashcards":await _.updateFlashcard(e.documentId,e.localVersion,e.localVersion.userId);break;case"study_sessions":await C.updateSessionProgress(e.documentId,{cardsStudied:e.localVersion.cardsStudied,currentPerformance:e.localVersion.performance},e.localVersion.userId);break;case"study_statistics":await R.updateStudyStatistics(e.documentId,e.localVersion,e.localVersion.userId);break}}async mergeVersions(e){const t=new Date(e.localVersion.updatedAt||e.localVersion.createdAt).getTime(),s=new Date(e.remoteVersion.updatedAt||e.remoteVersion.createdAt).getTime();t>s&&await this.applyLocalVersion(e)}async applyMergedVersion(e,t){switch(e.collection){case"flashcards":await _.updateFlashcard(e.documentId,t,t.userId);break;case"study_sessions":await C.updateSessionProgress(e.documentId,{cardsStudied:t.cardsStudied,currentPerformance:t.performance},t.userId);break;case"study_statistics":await R.updateStudyStatistics(e.documentId,t,t.userId);break}}async getPendingSyncCounts(e,t){const s={flashcards:0,studySessions:0,studyStatistics:0};if(t){const a=await _.getDueFlashcards(e,{limit:1e4});a.success&&a.data&&(s.flashcards=a.data.filter(n=>new Date(n.updatedAt)>t).length);const r=await C.getUserStudySessions(e,{limit:1e3,dateRange:{start:t,end:new Date}});r.success&&r.data&&(s.studySessions=r.data.length);const i=await R.getStudyStatisticsRange(e,t,new Date,"daily",{limit:1e3});i.success&&i.data&&(s.studyStatistics=i.data.length)}return s}async transformMigrationData(e,t){const s={...e};return s.flashcards&&(s.flashcards=s.flashcards.map(a=>({...a,userId:t,cardId:a.cardId||`card_${Date.now()}_${Math.random()}`,createdAt:a.createdAt||new Date,updatedAt:a.updatedAt||new Date}))),s.studySessions&&(s.studySessions=s.studySessions.map(a=>({...a,userId:t,sessionId:a.sessionId||`session_${Date.now()}_${Math.random()}`,createdAt:a.createdAt||new Date,updatedAt:a.updatedAt||new Date}))),s.studyStatistics&&(s.studyStatistics=s.studyStatistics.map(a=>({...a,userId:t,statsId:a.statsId||`stats_${Date.now()}_${Math.random()}`,createdAt:a.createdAt||new Date,updatedAt:a.updatedAt||new Date}))),s}async validateMigrationData(e){const t=[];if(e.flashcards)for(const s of e.flashcards)(!s.front||!s.back||!s.category)&&t.push("Invalid flashcard: missing required fields");if(e.studySessions)for(const s of e.studySessions)(!s.startTime||!s.cardsStudied)&&t.push("Invalid study session: missing required fields");if(e.studyStatistics)for(const s of e.studyStatistics)(!s.date||!s.dailyStats)&&t.push("Invalid study statistics: missing required fields");return{isValid:t.length===0,errors:t}}}const se=new Ae;class x{constructor(){this.services={users:M,flashcards:_,studySessions:C,studyStatistics:R,bulkOperations:B,sync:se}}static getInstance(){return x.instance||(x.instance=new x),x.instance}getServices(){return this.services}getUserService(){return this.services.users}getFlashcardService(){return this.services.flashcards}getStudySessionService(){return this.services.studySessions}getStudyStatisticsService(){return this.services.studyStatistics}getBulkOperationsService(){return this.services.bulkOperations}getSyncService(){return this.services.sync}}const Be={users:M,flashcards:_,studySessions:C,studyStatistics:R,bulkOperations:B,sync:se,factory:x.getInstance(),errorHandler:Te,safeAsync:l,databaseUtils:le,getDatabase:oe,initializeDatabase:ie,closeDatabase:ne,validateDocument:O,sanitizeInput:A,calculateNextReviewDate:Y,getDefaultSM2Params:te,validateObjectId:Se,validateRequired:z,validateQuality:Z,validateOwnership:U};export{he as BulkOperationError,me as CollectionName,ye as ConnectionError,p as DatabaseError,Pe as DatabaseIndexes,$ as DuplicateError,Q as ErrorHandler,P as FlashcardSchema,Me as MigrationError,we as MigrationSchema,k as NotFoundError,fe as PermissionError,$e as RateLimitError,J as SM2Error,je as Schemas,x as ServiceFactory,ee as StudySessionSchema,X as StudyStatisticsSchema,q as UserSchema,T as ValidationError,B as bulkOperationsService,Y as calculateNextReviewDate,ne as closeDatabase,L as createDatabaseOperations,xe as databaseConfig,le as databaseUtils,j as dbConnection,Be as default,_e as emailValidator,Te as errorHandler,_ as flashcardsService,oe as getDatabase,te as getDefaultSM2Params,ie as initializeDatabase,ze as qualityValidator,l as safeAsync,A as sanitizeInput,be as sm2Validator,C as studySessionsService,R as studyStatisticsService,se as syncService,G as urlValidator,M as usersService,O as validateDocument,Se as validateObjectId,U as validateOwnership,Z as validateQuality,z as validateRequired,Ve as validateSM2Params};
