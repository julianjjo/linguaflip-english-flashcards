import{h as p}from"./Header.astro_astro_type_script_index_0_lang.D70yTJYG.js";import{r as f}from"./react-vendor.DGywmNEQ.js";import{D as T}from"./vendor.QRJdyujs.js";const y={},_=Object.freeze(Object.defineProperty({__proto__:null,default:y},Symbol.toStringTag,{value:"Module"}));class h{static{this.auditLog=[]}static logSecurityEvent(e,t,s="low"){this.auditLog.push({timestamp:new Date,action:e,details:t,severity:s}),this.auditLog.length>1e3&&(this.auditLog=this.auditLog.slice(-1e3)),s==="high"&&console.error(`[SECURITY AUDIT - HIGH] ${e}:`,t)}static getAuditLog(){return[...this.auditLog]}static getHighSeverityEvents(){return this.auditLog.filter(e=>e.severity==="high")}static clearAuditLog(){this.auditLog=[]}}const i={accessTokenKey:"linguaflip_access_token",refreshTokenKey:"linguaflip_refresh_token",tokenExpiryKey:"linguaflip_token_expiry",storagePrefix:"linguaflip_secure_",encryptionKey:"linguaflip_token_encryption_key",maxRetries:3,retryDelay:1e3};class u{static{this.encryptionKey=i.encryptionKey}static{this.isEncryptionEnabled=!0}static async storeAccessToken(e,t){try{const s=Date.now()+t*1e3,r=this.isEncryptionEnabled?await this.encryptData(e):e;localStorage.setItem(i.accessTokenKey,r),localStorage.setItem(i.tokenExpiryKey,s.toString());const a=await this.generateChecksum(e);localStorage.setItem(`${i.storagePrefix}checksum`,a),h.logSecurityEvent("ACCESS_TOKEN_STORED",{hasToken:!!e,expiresIn:t},"low")}catch(s){throw console.error("Failed to store access token:",s),h.logSecurityEvent("TOKEN_STORAGE_ERROR",{error:s instanceof Error?s.message:"Unknown error"},"medium"),new Error("Failed to securely store access token")}}static async getAccessToken(){try{const e=localStorage.getItem(i.accessTokenKey),t=localStorage.getItem(i.tokenExpiryKey),s=localStorage.getItem(`${i.storagePrefix}checksum`);if(!e||!t)return null;const r=parseInt(t);if(Date.now()>r)return this.clearTokens(),null;const a=this.isEncryptionEnabled?await this.decryptData(e):e;return s&&await this.generateChecksum(a)!==s?(h.logSecurityEvent("TOKEN_INTEGRITY_CHECK_FAILED",{},"high"),this.clearTokens(),null):a}catch(e){return console.error("Failed to retrieve access token:",e),this.clearTokens(),null}}static storeRefreshTokenReference(e){try{const t=this.hashToken(e);localStorage.setItem(i.refreshTokenKey,t),h.logSecurityEvent("REFRESH_TOKEN_REFERENCE_STORED",{hasToken:!!e},"low")}catch(t){console.error("Failed to store refresh token reference:",t)}}static hasRefreshToken(){return!!localStorage.getItem(i.refreshTokenKey)}static clearTokens(){try{localStorage.removeItem(i.accessTokenKey),localStorage.removeItem(i.refreshTokenKey),localStorage.removeItem(i.tokenExpiryKey),localStorage.removeItem(`${i.storagePrefix}checksum`),Object.keys(localStorage).forEach(e=>{e.startsWith(i.storagePrefix)&&localStorage.removeItem(e)}),h.logSecurityEvent("TOKENS_CLEARED",{},"low")}catch(e){console.error("Failed to clear tokens:",e)}}static isAccessTokenExpired(){try{const e=localStorage.getItem(i.tokenExpiryKey);if(!e)return!0;const t=parseInt(e);return Date.now()>t}catch{return!0}}static getTimeUntilExpiry(){try{const e=localStorage.getItem(i.tokenExpiryKey);if(!e)return 0;const t=parseInt(e);return Math.max(0,t-Date.now())}catch{return 0}}static async encryptData(e){try{const s=new TextEncoder().encode(e),r=await this.getEncryptionKey(),a=crypto.getRandomValues(new Uint8Array(12)),o=await crypto.subtle.encrypt({name:"AES-GCM",iv:a},r,s),n=new Uint8Array(o),c=new Uint8Array(a.length+n.length);return c.set(a),c.set(n,a.length),btoa(String.fromCharCode(...c))}catch(t){return console.warn("Encryption failed, falling back to plain storage:",t),this.isEncryptionEnabled=!1,e}}static async decryptData(e){try{const t=Uint8Array.from(atob(e),c=>c.charCodeAt(0));if(t.length<=12)throw new Error("Invalid encrypted data");const s=t.slice(0,12),r=t.slice(12),a=await this.getEncryptionKey(),o=await crypto.subtle.decrypt({name:"AES-GCM",iv:s},a,r);return new TextDecoder().decode(o)}catch(t){throw console.warn("Decryption failed:",t),new Error("Failed to decrypt data")}}static async getEncryptionKey(){const e=new TextEncoder,t=await crypto.subtle.importKey("raw",e.encode(this.encryptionKey),"PBKDF2",!1,["deriveBits","deriveKey"]);return crypto.subtle.deriveKey({name:"PBKDF2",salt:e.encode("linguaflip_salt"),iterations:1e5,hash:"SHA-256"},t,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}static async generateChecksum(e){const s=new TextEncoder().encode(e),r=await crypto.subtle.digest("SHA-256",s);return Array.from(new Uint8Array(r)).map(o=>o.toString(16).padStart(2,"0")).join("")}static hashToken(e){let t=0;for(let s=0;s<e.length;s++){const r=e.charCodeAt(s);t=(t<<5)-t+r,t=t&t}return t.toString()}}class O{static{this.refreshPromise=null}static{this.refreshTimer=null}static{this.REFRESH_THRESHOLD=300*1e3}static startAutoRefresh(){this.stopAutoRefresh();const e=async()=>{try{const t=u.getTimeUntilExpiry(),s=!!await u.getAccessToken(),r=u.hasRefreshToken();console.log("[TOKEN_DEBUG] Auto-refresh check:",{timeUntilExpiry:t,hasAccessToken:s,hasRefreshToken:r,refreshPromise:!!this.refreshPromise,timestamp:new Date().toISOString()}),t>0&&t<=this.REFRESH_THRESHOLD?(console.log("[TOKEN_DEBUG] Token near expiry, attempting refresh:",{timeUntilExpiry:t,threshold:this.REFRESH_THRESHOLD}),await this.refreshAccessToken()):t<=0&&(console.log("[TOKEN_DEBUG] Token expired, clearing tokens"),u.clearTokens())}catch(t){console.error("[TOKEN_DEBUG] Auto refresh failed:",t),h.logSecurityEvent("AUTO_REFRESH_ERROR",{error:t instanceof Error?t.message:"Unknown error"},"medium")}this.refreshTimer=setTimeout(e,6e4)};console.log("[TOKEN_DEBUG] Starting auto-refresh timer"),e()}static stopAutoRefresh(){this.refreshTimer&&(clearTimeout(this.refreshTimer),this.refreshTimer=null)}static async refreshAccessToken(){if(this.refreshPromise)return console.log("[TOKEN_DEBUG] Refresh already in progress, returning existing promise"),this.refreshPromise;console.log("[TOKEN_DEBUG] Starting token refresh process"),this.refreshPromise=this.performTokenRefresh();try{const e=await this.refreshPromise;return console.log("[TOKEN_DEBUG] Token refresh successful"),e}catch(e){throw console.error("[TOKEN_DEBUG] Token refresh failed:",e),e}finally{console.log("[TOKEN_DEBUG] Clearing refresh promise"),this.refreshPromise=null}}static async performTokenRefresh(){try{console.log("[TOKEN_DEBUG] Making refresh request to server");const e=await fetch("/api/auth/refresh",{method:"POST",headers:{"Content-Type":"application/json"},credentials:"include"});if(console.log("[TOKEN_DEBUG] Refresh response status:",e.status),!e.ok)throw e.status===401?(console.log("[TOKEN_DEBUG] Refresh token expired (401), clearing tokens"),u.clearTokens(),new Error("Refresh token expired")):(console.log("[TOKEN_DEBUG] Refresh failed with status:",e.status),new Error(`Token refresh failed: ${e.status}`));const t=await e.json();if(console.log("[TOKEN_DEBUG] Refresh response data:",{success:t.success,hasAccessToken:!!t.data?.accessToken,hasRefreshToken:!!t.data?.refreshToken}),t.success&&t.data.accessToken)return await u.storeAccessToken(t.data.accessToken,t.data.expiresIn/1e3),h.logSecurityEvent("ACCESS_TOKEN_REFRESHED",{},"low"),t.data.accessToken;throw console.error("[TOKEN_DEBUG] Invalid refresh response structure:",t),new Error("Invalid refresh response")}catch(e){throw console.error("[TOKEN_DEBUG] Token refresh failed:",e),h.logSecurityEvent("TOKEN_REFRESH_FAILED",{error:e instanceof Error?e.message:"Unknown error"},"medium"),e}}}class R{static{this.listeners=[]}static{this.isAuthenticated=!1}static async checkAuthentication(){try{console.log("[AUTH_DEBUG] Checking authentication status");const e=await u.getAccessToken();if(!e)return console.log("[AUTH_DEBUG] No access token found"),this.setAuthenticated(!1),!1;console.log("[AUTH_DEBUG] Verifying token with server");const t=await fetch("/api/auth/verify",{headers:{Authorization:`Bearer ${e}`}}),s=t.ok;return console.log("[AUTH_DEBUG] Server verification result:",{status:t.status,isAuthenticated:s,currentAuthState:this.isAuthenticated}),this.setAuthenticated(s),s||(console.log("[AUTH_DEBUG] Token verification failed, clearing tokens"),u.clearTokens()),s}catch(e){return console.error("[AUTH_DEBUG] Authentication check failed:",e),this.setAuthenticated(!1),u.clearTokens(),!1}}static setAuthenticated(e){this.isAuthenticated!==e?(console.log("[AUTH_DEBUG] Authentication state changing:",{from:this.isAuthenticated,to:e,timestamp:new Date().toISOString()}),this.isAuthenticated=e,this.notifyListeners(e)):console.log("[AUTH_DEBUG] Authentication state unchanged:",e)}static getIsAuthenticated(){return this.isAuthenticated}static subscribe(e){return this.listeners.push(e),()=>{const t=this.listeners.indexOf(e);t>-1&&this.listeners.splice(t,1)}}static notifyListeners(e){this.listeners.forEach(t=>{try{t(e)}catch(s){console.error("Auth state listener error:",s)}})}}class x{static{this.EXPORT_VERSION="1.0.0"}static{this.STORAGE_KEYS={CARDS:"linguaFlipCards",SESSIONS:"linguaFlipStudySessions"}}static exportAllData(){const e=this.loadCardsFromStorage(),t=this.loadSessionsFromStorage();return{version:this.EXPORT_VERSION,exportDate:new Date().toISOString(),flashcards:e,studySessions:t,metadata:{totalCards:e.length,totalSessions:t.length,exportType:"full"}}}static exportProgressData(){const e=this.loadSessionsFromStorage();return{version:this.EXPORT_VERSION,exportDate:new Date().toISOString(),flashcards:[],studySessions:e,metadata:{totalCards:0,totalSessions:e.length,exportType:"progress-only"}}}static downloadExportData(e,t){const s=JSON.stringify(e,null,2),r="data:application/json;charset=utf-8,"+encodeURIComponent(s),a=t||`linguaflip-backup-${new Date().toISOString().split("T")[0]}.json`,o=document.createElement("a");o.setAttribute("href",r),o.setAttribute("download",a),o.click()}static async importData(e){return new Promise(t=>{const s=new FileReader;s.onload=r=>{try{const a=r.target?.result,o=JSON.parse(a);if(!this.validateImportData(o)){t({success:!1,message:"Invalid file format. Please select a valid LinguaFlip export file."});return}const n=this.processImport(o);t(n)}catch{t({success:!1,message:"Failed to parse the import file. Please ensure it's a valid JSON file."})}},s.onerror=()=>{t({success:!1,message:"Failed to read the file. Please try again."})},s.readAsText(e)})}static validateImportData(e){if(!e||typeof e!="object")return!1;const t=e;try{return typeof t.version=="string"&&typeof t.exportDate=="string"&&Array.isArray(t.flashcards)&&Array.isArray(t.studySessions)&&t.metadata&&typeof t.metadata.totalCards=="number"&&typeof t.metadata.totalSessions=="number"&&(t.metadata.exportType==="full"||t.metadata.exportType==="progress-only")}catch{return!1}}static processImport(e){try{return e.flashcards.length>0&&localStorage.setItem(this.STORAGE_KEYS.CARDS,JSON.stringify(e.flashcards)),e.studySessions.length>0&&localStorage.setItem(this.STORAGE_KEYS.SESSIONS,JSON.stringify(e.studySessions)),{success:!0,message:e.metadata.exportType==="full"?`Successfully imported ${e.flashcards.length} cards and ${e.studySessions.length} study sessions.`:`Successfully imported ${e.studySessions.length} study sessions.`,data:e}}catch{return{success:!1,message:"Failed to save imported data. Please try again.",data:e}}}static loadCardsFromStorage(){try{const e=localStorage.getItem(this.STORAGE_KEYS.CARDS);return e?JSON.parse(e):[]}catch(e){return console.error("Failed to load cards from storage:",e),[]}}static loadSessionsFromStorage(){try{const e=localStorage.getItem(this.STORAGE_KEYS.SESSIONS);return e?JSON.parse(e):[]}catch(e){return console.error("Failed to load sessions from storage:",e),[]}}static clearAllData(){localStorage.removeItem(this.STORAGE_KEYS.CARDS),localStorage.removeItem(this.STORAGE_KEYS.SESSIONS)}static getDataSummary(){const e=this.loadCardsFromStorage(),t=this.loadSessionsFromStorage(),s=t.sort((a,o)=>new Date(o.date).getTime()-new Date(a.date).getTime())[0],r=s?s.date:void 0;return{cardsCount:e.length,sessionsCount:t.length,lastBackup:r}}}class E{constructor(e){this.progressCallback=e}async analyzeLocalData(){const e={flashcards:[],studySessions:[],progressStats:null,studyProfiles:[]};try{const t=localStorage.getItem("flashcards");if(t){const o=JSON.parse(t);Array.isArray(o)&&(e.flashcards=o.filter(n=>n&&typeof n=="object"&&n.id&&n.english&&n.spanish))}const s=localStorage.getItem("studySessions");if(s){const o=JSON.parse(s);Array.isArray(o)&&(e.studySessions=o.filter(n=>n&&typeof n=="object"&&n.id&&n.date))}const r=localStorage.getItem("progressStats");if(r){const o=JSON.parse(r);o&&typeof o=="object"&&(e.progressStats=o)}const a=localStorage.getItem("studyProfiles");if(a){const o=JSON.parse(a);Array.isArray(o)&&(e.studyProfiles=o.filter(n=>n&&typeof n=="object"&&n.id&&n.name))}}catch(t){console.error("Error analyzing local data:",t)}return e}async migrateToMongoDB(e){const t=Date.now();this.abortController=new AbortController;const s={success:!0,migratedItems:{flashcards:0,studySessions:0,progressStats:0},skippedItems:0,errors:[],duration:0};try{this.updateProgress({stage:"analyzing",totalItems:0,processedItems:0,currentItem:"Analyzing local data...",errors:[]});const r=await this.analyzeLocalData(),a=r.flashcards.length+r.studySessions.length+(r.progressStats?1:0);if(this.updateProgress({stage:"migrating_flashcards",totalItems:a,processedItems:0,currentItem:"Starting migration...",errors:[]}),this.abortController.signal.aborted)throw new Error("Migration aborted by user");if(r.flashcards.length>0){this.updateProgress({stage:"migrating_flashcards",totalItems:a,processedItems:0,currentItem:`Migrating ${r.flashcards.length} flashcards...`,errors:[]});for(let o=0;o<r.flashcards.length;o++){if(this.abortController.signal.aborted)throw new Error("Migration aborted by user");const n=r.flashcards[o];try{await p.saveFlashcard(e,n),s.migratedItems.flashcards++,this.updateProgress({stage:"migrating_flashcards",totalItems:a,processedItems:s.migratedItems.flashcards+s.migratedItems.studySessions,currentItem:`Migrating flashcard: ${n.english}`,errors:s.errors})}catch(c){const d=`Failed to migrate flashcard ${n.id}: ${c}`;s.errors.push(d),s.skippedItems++,console.error(d)}}}if(r.studySessions.length>0){this.updateProgress({stage:"migrating_sessions",totalItems:a,processedItems:s.migratedItems.flashcards,currentItem:`Migrating ${r.studySessions.length} study sessions...`,errors:s.errors});for(let o=0;o<r.studySessions.length;o++){if(this.abortController.signal.aborted)throw new Error("Migration aborted by user");const n=r.studySessions[o];try{await p.saveStudySession(e,n),s.migratedItems.studySessions++,this.updateProgress({stage:"migrating_sessions",totalItems:a,processedItems:s.migratedItems.flashcards+s.migratedItems.studySessions,currentItem:`Migrating session: ${n.id}`,errors:s.errors})}catch(c){const d=`Failed to migrate study session ${n.id}: ${c}`;s.errors.push(d),s.skippedItems++,console.error(d)}}}if(r.progressStats){this.updateProgress({stage:"migrating_stats",totalItems:a,processedItems:s.migratedItems.flashcards+s.migratedItems.studySessions,currentItem:"Migrating progress statistics...",errors:s.errors});try{s.migratedItems.progressStats=1,this.updateProgress({stage:"migrating_stats",totalItems:a,processedItems:a,currentItem:"Progress statistics migrated",errors:s.errors})}catch(o){const n=`Failed to migrate progress stats: ${o}`;s.errors.push(n),s.skippedItems++,console.error(n)}}this.updateProgress({stage:"completed",totalItems:a,processedItems:a,currentItem:"Migration completed successfully!",errors:s.errors}),await p.forceSync(e)}catch(r){s.success=!1;const a=r instanceof Error?r.message:"Migration failed";s.errors.push(a),this.updateProgress({stage:"error",totalItems:0,processedItems:0,currentItem:`Migration failed: ${a}`,errors:s.errors}),console.error("Migration failed:",r)}finally{s.duration=Date.now()-t}return s}createBackup(){const e={},t=["flashcards","studySessions","progressStats","studyProfiles","userPreferences","studySettings"];for(const s of t){const r=localStorage.getItem(s);r&&(e[s]=JSON.parse(r))}return e._metadata={createdAt:new Date().toISOString(),version:"1.0",type:"linguaflip_backup"},JSON.stringify(e,null,2)}restoreFromBackup(e){try{const t=JSON.parse(e);if(!t._metadata||t._metadata.type!=="linguaflip_backup")throw new Error("Invalid backup file");for(const[s,r]of Object.entries(t))s!=="_metadata"&&s in t&&localStorage.setItem(s,JSON.stringify(r));return!0}catch(t){return console.error("Failed to restore from backup:",t),!1}}clearMigratedData(){const e=["flashcards","studySessions","progressStats","studyProfiles"];for(const t of e)localStorage.removeItem(t);localStorage.setItem("migration_completed",new Date().toISOString())}isMigrationCompleted(){return localStorage.getItem("migration_completed")!==null}abortMigration(){this.abortController&&this.abortController.abort()}updateProgress(e){this.progressCallback&&this.progressCallback(e)}}function k(){const e=new E().createBackup(),t=new Blob([e],{type:"application/json"}),s=URL.createObjectURL(t),r=document.createElement("a");r.href=s,r.download=`linguaflip-backup-${new Date().toISOString().split("T")[0]}.json`,document.body.appendChild(r),r.click(),document.body.removeChild(r),URL.revokeObjectURL(s)}function C(){const[l,e]=f.useState(!1),[t,s]=f.useState(null),[r,a]=f.useState(null),o=f.useCallback(async d=>{e(!0),a(null);const S=new E(g=>{s(g)});try{const g=await S.migrateToMongoDB(d);return a(g),g.success&&g.errors.length===0&&S.clearMigratedData(),g}finally{e(!1)}},[]),n=f.useCallback(()=>{k()},[]),c=f.useCallback(()=>{console.warn("Abort functionality requires migrator instance reference")},[]);return{migrateData:o,createBackup:n,abortMigration:c,isMigrating:l,progress:t,result:r}}var m={};const w="linguaflip-d1.sqlite";class D{constructor(){this.remoteStatus="unknown",this.localDb=null,this.schemaInitialized=!1,this.remoteUrl=m.D1_URL?m.D1_URL.replace(/\/$/,""):null,this.apiKey=m.D1_API_KEY||null,this.accountId=m.CLOUDFLARE_ACCOUNT_ID||null,this.databaseId=m.D1_DATABASE_ID||null,!this.remoteUrl&&this.accountId&&this.databaseId&&(this.remoteUrl=`https://api.cloudflare.com/client/v4/accounts/${this.accountId}/d1/database/${this.databaseId}`)}async execute(e,t=[]){if(this.shouldUseRemote())try{const s=await this.executeRemote(e,t);return this.remoteStatus="available",s}catch(s){const r=s instanceof Error?s.message:String(s);console.warn(`Remote D1 query failed (${r}). Falling back to local SQLite.`),this.remoteStatus="failed",this.ensureLocalDatabase()}return this.ensureLocalDatabase(),this.executeLocal(e,t)}async executeBatch(e){const t=[];if(this.shouldUseRemote())try{const a=await this.executeRemoteBatch(e);return this.remoteStatus="available",a}catch(a){const o=a instanceof Error?a.message:String(a);console.warn(`Remote D1 batch failed (${o}). Falling back to local SQLite.`),this.remoteStatus="failed",this.ensureLocalDatabase()}this.ensureLocalDatabase();const r=this.localDb.transaction(a=>{for(const{sql:o,params:n}of a){const c=this.executeLocal(o,n||[]);if(t.push(c),!c.success)throw new Error(c.error||"Unknown SQLite error")}});try{return r(e),t}catch(a){return[{success:!1,error:a instanceof Error?a.message:String(a)}]}}isRemote(){return this.remoteStatus==="available"}async close(){this.localDb&&(this.localDb.close(),this.localDb=null)}async initializeSchema(e){if(!this.schemaInitialized){for(const t of e){const s=await this.execute(t);if(!s.success)throw new Error(s.error||"Failed to initialize D1 schema")}this.schemaInitialized=!0}}shouldUseRemote(){return!(!this.remoteUrl||!this.apiKey||this.remoteStatus==="failed")}async executeRemote(e,t){const s=Array.isArray(e)?{sql:e,params:t}:{sql:e,params:t},r=await fetch(`${this.remoteUrl}/query`,{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${this.apiKey}`},body:JSON.stringify(s)});if(!r.ok){const o=await r.text();throw new Error(`Cloudflare D1 responded with ${r.status}: ${o}`)}const a=await r.json();if(Array.isArray(a?.result)){const o=a.result[0];return{success:!0,results:o?.results||[],meta:o?.meta}}return a?.result?.results?{success:!0,results:a.result.results,meta:a.result.meta}:{success:a?.success??!1,results:Array.isArray(a?.result)?a.result:[],meta:a?.result?.meta,error:a?.errors?.length?JSON.stringify(a.errors):void 0}}async executeRemoteBatch(e){const t=e.map(a=>({sql:a.sql,params:a.params||[]})),s=await fetch(`${this.remoteUrl}/query`,{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${this.apiKey}`},body:JSON.stringify(t)});if(!s.ok){const a=await s.text();throw new Error(`Cloudflare D1 responded with ${s.status}: ${a}`)}const r=await s.json();return Array.isArray(r?.result)?r.result.map(a=>({success:!0,results:a?.results||[],meta:a?.meta})):[{success:r?.success??!1,results:r?.result?.results||[],meta:r?.result?.meta,error:r?.errors?.length?JSON.stringify(r.errors):void 0}]}executeLocal(e,t){if(!this.localDb)throw new Error("Local SQLite database not initialized");const s=t.map(n=>this.normalizeParam(n)),r=e.trim().toLowerCase(),a=this.localDb.prepare(e);if(r.startsWith("select")||r.startsWith("with")||r.startsWith("pragma"))return{success:!0,results:a.all(...s)};const o=a.run(...s);return{success:!0,meta:{changes:o.changes,lastInsertRowid:Number(o.lastInsertRowid||0)}}}ensureLocalDatabase(){if(this.localDb)return;const e=y.join(process.cwd(),".d1-cache");y.existsSync(e)||y.mkdirSync(e,{recursive:!0});const t=y.join(e,w);this.localDb=new T(t)}normalizeParam(e){return e===void 0?null:e instanceof Date?e.toISOString():Array.isArray(e)?JSON.stringify(e):e}}const U=new D;export{R as A,x as D,u as S,O as T,_,h as a,U as d,C as u};
