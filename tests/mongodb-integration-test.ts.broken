// Comprehensive MongoDB Integration Test Suite
import { MongoClient } from 'mongodb';
import { getMockMongoDBServer } from './mongodb-mock-server.js';
import { validateMongoDBEnvironment, buildSecureConnectionString, sanitizeConnectionString } from '../src/utils/security.ts';
import { DatabaseConnection } from '../src/utils/database.ts';
import { DatabaseOperations } from '../src/utils/databaseOperations.ts';

// Test configuration
const TEST_CONFIG = {
  connectionTimeout: 5000,
  testDatabase: 'linguaflip_test',
  testCollections: {
    users: 'users',
    flashcards: 'flashcards',
    studySessions: 'study_sessions',
    studyStatistics: 'study_statistics'
  }
};

describe('MongoDB Integration Tests', () => {
  let mockServer: any;
  let client: MongoClient;
  let db: any;
  let dbOps: any;

  beforeAll(async () => {
    try {
      // Start mock MongoDB server
      mockServer = getMockMongoDBServer();
      const mongoUri = await mockServer.start();

      // Override environment for testing
      process.env.NODE_ENV = 'test';
      process.env.MONGODB_TEST_URI = mongoUri;
      process.env.MONGODB_TEST_DATABASE = TEST_CONFIG.testDatabase;

      // Connect using our database utilities
      const dbConnection = DatabaseConnection.getInstance();
      await dbConnection.connect();

      db = dbConnection.getDatabase();
      client = dbConnection.getClient();

      console.log('Test database connection established');
    } catch (error) {
      console.error('Failed to setup test database:', error);
      throw error;
    }
  });

  afterAll(async () => {
    try {
      // Clean up database connection
      const dbConnection = DatabaseConnection.getInstance();
      await dbConnection.close();

      // Stop mock server
      if (mockServer) {
        await mockServer.stop();
      }

      console.log('Test database cleanup completed');
    } catch (error) {
      console.error('Error during test cleanup:', error);
    }
  }, 10000);

  beforeEach(async () => {
    // Clear all collections before each test
    if (mockServer && mockServer.isServerRunning()) {
      await mockServer.clearDatabase();
    }
  });

  describe('Database Connection & Configuration', () => {
    test('should validate test environment configuration', () => {
      const validation = validateMongoDBEnvironment();

      expect(validation.isValid).toBe(true);
      expect(validation.errors).toHaveLength(0);
      console.log('Environment validation warnings:', validation.warnings);
    });

    test('should build secure connection string', () => {
      const connectionString = buildSecureConnectionString();
      expect(connectionString).toBeDefined();
      expect(typeof connectionString).toBe('string');
      expect(connectionString.length).toBeGreaterThan(0);
    });

    test('should sanitize connection strings for logging', () => {
      const testUri = 'mongodb+srv://user:password123@cluster.mongodb.net/db';
      const sanitized = sanitizeConnectionString(testUri);

      expect(sanitized).not.toMatch(/password123/);
      expect(sanitized).toMatch(/user/);
      expect(sanitized).toMatch(/\*\*\*\*/);
    });

    test('should establish database connection successfully', async () => {
      expect(db).toBeDefined();
      expect(client).toBeDefined();

      // Test basic connectivity
      const pingResult = await db.admin().ping();
      expect(pingResult.ok).toBe(1);
    });

    test('should handle connection health checks', async () => {
      const dbConnection = DatabaseConnection.getInstance();
      const healthCheck = await dbConnection.healthCheck();

      expect(healthCheck.status).toBe('connected');
      expect(healthCheck.database).toBe(TEST_CONFIG.testDatabase);
      expect(Array.isArray(healthCheck.collections)).toBe(true);
    });
  });

  describe('CRUD Operations - Users Collection', () => {
    let userOps;

    beforeAll(() => {
      userOps = new DatabaseOperations(TEST_CONFIG.testCollections.users);
    });

    const testUser = {
      username: 'testuser',
      email: 'test@example.com',
      passwordHash: 'hashed_password',
      preferences: {
        theme: 'light',
        language: 'en',
        notifications: true
      }
    };

    test('should create user document', async () => {
      const result = await userOps.create(testUser);

      expect(result.success).toBe(true);
      expect(result.data).toBeDefined();
      expect(result.data._id).toBeDefined();
      expect(result.data.username).toBe(testUser.username);
      expect(result.data.email).toBe(testUser.email);
      expect(result.data.createdAt).toBeDefined();
      expect(result.data.updatedAt).toBeDefined();
    });

    test('should find user by email', async () => {
      await userOps.create(testUser);

      const result = await userOps.findOne({ email: testUser.email });

      expect(result.success).toBe(true);
      expect(result.data).toBeDefined();
      expect(result.data.email).toBe(testUser.email);
    });

    test('should update user preferences', async () => {
      const createResult = await userOps.create(testUser);
      const userId = createResult.data._id;

      const updateResult = await userOps.updateOne(
        { _id: userId },
        { $set: { 'preferences.theme': 'dark' } }
      );

      expect(updateResult.success).toBe(true);
      expect(updateResult.data.preferences.theme).toBe('dark');
    });

    test('should delete user document', async () => {
      const createResult = await userOps.create(testUser);
      const userId = createResult.data._id;

      const deleteResult = await userOps.deleteOne({ _id: userId });

      expect(deleteResult.success).toBe(true);
      expect(deleteResult.data.deletedCount).toBe(1);

      // Verify deletion
      const findResult = await userOps.findOne({ _id: userId });
      expect(findResult.data).toBeNull();
    });
  });

  describe('CRUD Operations - Flashcards Collection', () => {
    let flashcardOps;

    beforeAll(() => {
      flashcardOps = new DatabaseOperations(TEST_CONFIG.testCollections.flashcards);
    });

    const testFlashcard = {
      userId: 'user123',
      front: 'Hello',
      back: 'Hola',
      difficulty: 2.5,
      nextReview: new Date(Date.now() + 24 * 60 * 60 * 1000), // Tomorrow
      reviewCount: 0,
      correctCount: 0,
      incorrectCount: 0,
      tags: ['greetings', 'basic'],
      audioUrl: '/audio/hello.mp3'
    };

    test('should create flashcard document', async () => {
      const result = await flashcardOps.create(testFlashcard);

      expect(result.success).toBe(true);
      expect(result.data.front).toBe(testFlashcard.front);
      expect(result.data.back).toBe(testFlashcard.back);
      expect(result.data.difficulty).toBe(testFlashcard.difficulty);
    });

    test('should find flashcards by user and tags', async () => {
      await flashcardOps.create(testFlashcard);

      const result = await flashcardOps.findMany({
        userId: testFlashcard.userId,
        tags: { $in: ['greetings'] }
      });

      expect(result.success).toBe(true);
      expect(result.data.length).toBeGreaterThan(0);
      expect(result.data[0].tags).toContain('greetings');
    });

    test('should update flashcard statistics', async () => {
      const createResult = await flashcardOps.create(testFlashcard);
      const cardId = createResult.data._id;

      const updateResult = await flashcardOps.updateOne(
        { _id: cardId },
        {
          $inc: { reviewCount: 1, correctCount: 1 },
          $set: { nextReview: new Date(Date.now() + 3 * 24 * 60 * 60 * 1000) }
        }
      );

      expect(updateResult.success).toBe(true);
      expect(updateResult.data.reviewCount).toBe(1);
      expect(updateResult.data.correctCount).toBe(1);
    });
  });

  describe('Bulk Operations', () => {
    let bulkOps;

    beforeAll(() => {
      bulkOps = new DatabaseOperations(TEST_CONFIG.testCollections.flashcards);
    });

    test('should perform bulk insert operations', async () => {
      const flashcards = Array.from({ length: 10 }, (_, i) => ({
        userId: 'bulk_test_user',
        front: `Front ${i}`,
        back: `Back ${i}`,
        difficulty: 2.5,
        nextReview: new Date(),
        reviewCount: 0,
        correctCount: 0,
        incorrectCount: 0,
        tags: ['bulk', 'test']
      }));

      const operations = flashcards.map(card => ({
        insertOne: { document: card }
      }));

      const result = await bulkOps.bulkWrite(operations);

      expect(result.success).toBe(true);
      expect(result.data.success).toBe(true);
      expect(result.data.insertedCount).toBe(10);
    });

    test('should perform bulk update operations', async () => {
      // First create some test data
      const flashcards = Array.from({ length: 5 }, (_, i) => ({
        userId: 'bulk_update_user',
        front: `Front ${i}`,
        back: `Back ${i}`,
        difficulty: 2.5,
        nextReview: new Date(),
        reviewCount: 0,
        correctCount: 0,
        incorrectCount: 0,
        tags: ['bulk', 'update']
      }));

      for (const card of flashcards) {
        await bulkOps.create(card);
      }

      // Perform bulk update
      const updateOperations = flashcards.map((_, i) => ({
        updateMany: {
          filter: { userId: 'bulk_update_user', front: `Front ${i}` },
          update: { $set: { difficulty: 3.0 } }
        }
      }));

      const result = await bulkOps.bulkWrite(updateOperations);

      expect(result.success).toBe(true);
      expect(result.data.updatedCount).toBe(5);
    });
  });

  describe('Aggregation & Analytics', () => {
    let analyticsOps;

    beforeAll(async () => {
      analyticsOps = new DatabaseOperations(TEST_CONFIG.testCollections.studyStatistics);

      // Seed test data
      const testData = Array.from({ length: 20 }, (_, i) => ({
        userId: 'analytics_user',
        sessionId: `session_${i}`,
        date: new Date(Date.now() - i * 24 * 60 * 60 * 1000), // Last 20 days
        cardsStudied: Math.floor(Math.random() * 50) + 10,
        correctAnswers: Math.floor(Math.random() * 40) + 5,
        incorrectAnswers: Math.floor(Math.random() * 10) + 1,
        timeSpent: Math.floor(Math.random() * 3600) + 300, // 5-65 minutes
        averageDifficulty: Math.random() * 2 + 1 // 1-3
      }));

      for (const data of testData) {
        await analyticsOps.create(data);
      }
    });

    test('should aggregate study statistics by date', async () => {
      const pipeline = [
        {
          $match: { userId: 'analytics_user' }
        },
        {
          $group: {
            _id: {
              $dateToString: { format: '%Y-%m-%d', date: '$date' }
            },
            totalCards: { $sum: '$cardsStudied' },
            totalCorrect: { $sum: '$correctAnswers' },
            totalTime: { $sum: '$timeSpent' },
            avgDifficulty: { $avg: '$averageDifficulty' }
          }
        },
        {
          $sort: { '_id': -1 }
        }
      ];

      const result = await analyticsOps.aggregate(pipeline);

      expect(result.success).toBe(true);
      expect(result.data.length).toBeGreaterThan(0);

      const firstResult = result.data[0];
      expect(firstResult).toHaveProperty('totalCards');
      expect(firstResult).toHaveProperty('totalCorrect');
      expect(firstResult).toHaveProperty('totalTime');
      expect(firstResult).toHaveProperty('avgDifficulty');
    });

    test('should calculate user performance metrics', async () => {
      const pipeline = [
        {
          $match: { userId: 'analytics_user' }
        },
        {
          $group: {
            _id: '$userId',
            totalSessions: { $sum: 1 },
            totalCardsStudied: { $sum: '$cardsStudied' },
            totalCorrect: { $sum: '$correctAnswers' },
            totalIncorrect: { $sum: '$incorrectAnswers' },
            totalTimeSpent: { $sum: '$timeSpent' },
            avgDifficulty: { $avg: '$averageDifficulty' }
          }
        },
        {
          $project: {
            accuracy: {
              $multiply: [
                { $divide: ['$totalCorrect', { $add: ['$totalCorrect', '$totalIncorrect'] }] },
                100
              ]
            },
            avgSessionTime: { $divide: ['$totalTimeSpent', '$totalSessions'] },
            cardsPerSession: { $divide: ['$totalCardsStudied', '$totalSessions'] },
            totalSessions: 1,
            totalCardsStudied: 1,
            avgDifficulty: 1
          }
        }
      ];

      const result = await analyticsOps.aggregate(pipeline);

      expect(result.success).toBe(true);
      expect(result.data.length).toBe(1);

      const metrics = result.data[0];
      expect(metrics).toHaveProperty('accuracy');
      expect(metrics).toHaveProperty('avgSessionTime');
      expect(metrics).toHaveProperty('cardsPerSession');
      expect(metrics.accuracy).toBeGreaterThan(0);
      expect(metrics.accuracy).toBeLessThanOrEqual(100);
    });
  });

  describe('Error Handling & Edge Cases', () => {
    let errorOps;

    beforeAll(() => {
      errorOps = new DatabaseOperations('error_test_collection');
    });

    test('should handle invalid ObjectId gracefully', async () => {
      const result = await errorOps.findOne({ _id: 'invalid-object-id' });

      expect(result.success).toBe(true);
      expect(result.data).toBeNull();
    });

    test('should handle non-existent documents', async () => {
      const result = await errorOps.findOne({ field: 'non-existent-value' });

      expect(result.success).toBe(true);
      expect(result.data).toBeNull();
    });

    test('should handle empty result sets', async () => {
      const result = await errorOps.findMany({ field: 'no-matches' });

      expect(result.success).toBe(true);
      expect(result.data).toEqual([]);
    });

    test('should handle update operations on non-existent documents', async () => {
      const result = await errorOps.updateOne(
        { _id: 'non-existent-id' },
        { $set: { field: 'value' } }
      );

      expect(result.success).toBe(true);
      expect(result.data).toBeNull();
    });

    test('should handle delete operations on non-existent documents', async () => {
      const result = await errorOps.deleteOne({ _id: 'non-existent-id' });

      expect(result.success).toBe(true);
      expect(result.data.deletedCount).toBe(0);
    });
  });

  describe('Performance & Load Testing', () => {
    let perfOps;

    beforeAll(() => {
      perfOps = new DatabaseOperations('performance_test');
    });

    test('should handle concurrent read operations', async () => {
      // Create test data
      const testDocuments = Array.from({ length: 100 }, (_, i) => ({
        index: i,
        data: `test_data_${i}`,
        timestamp: new Date()
      }));

      for (const doc of testDocuments) {
        await perfOps.create(doc);
      }

      // Perform concurrent reads
      const readPromises = Array.from({ length: 50 }, (_, i) =>
        perfOps.findOne({ index: i })
      );

      const startTime = Date.now();
      const results = await Promise.all(readPromises);
      const endTime = Date.now();

      const duration = endTime - startTime;

      expect(results.length).toBe(50);
      results.forEach(result => {
        expect(result.success).toBe(true);
        expect(result.data).toBeDefined();
      });

      console.log(`Concurrent reads completed in ${duration}ms`);
      expect(duration).toBeLessThan(5000); // Should complete within 5 seconds
    });

    test('should handle bulk write operations efficiently', async () => {
      const bulkDocuments = Array.from({ length: 1000 }, (_, i) => ({
        batch: 'performance_test',
        index: i,
        data: `bulk_test_data_${i}`,
        timestamp: new Date()
      }));

      const startTime = Date.now();

      const operations = bulkDocuments.map(doc => ({
        insertOne: { document: doc }
      }));

      const result = await perfOps.bulkWrite(operations);
      const endTime = Date.now();

      const duration = endTime - startTime;

      expect(result.success).toBe(true);
      expect(result.data.insertedCount).toBe(1000);

      console.log(`Bulk insert of 1000 documents completed in ${duration}ms`);
      expect(duration).toBeLessThan(10000); // Should complete within 10 seconds
    });
  });
});